[{"id":0,"title":"C++打造《瘋狂炸彈人》：從FSM到BFS的AI智能設計與物件導向實踐","date":"2025-05-15T00:00:00.000Z","plainText":"組員：113511103 吳沛恩、113511216 洪崧祐 課程：計算機概論與程式設計 期末專題 GitHub 專案連結：CrazyArcade-CPP-Game 一、專案啟程與目標 本專案旨在運用C++語言，結合物件導向程式設計（OOP）的原則，重現經典遊戲《瘋狂炸彈人》(Crazy Arcade)的核心玩法。我們不僅設計了單人（AI對戰）與雙人（玩家對戰）模式，更投入大量心力於電腦AI玩家的智能控制，目標是打造一個具備挑戰性、趣味性且系統架構清晰、可擴展的遊戲。 在這個過程中，我們不僅追求功能的實現，更將其視為一個深入學習和實踐OOP思想（如封裝與繼承）、演算法（如BFS路徑規劃）以及使用者介面（UI）設計的寶貴機會。 二、核心遊戲機制 2.1 遊戲流程概述 核心玩法： 玩家透過策略性地放置炸彈來攻擊對手，並在地圖中積極收集各種道具以增強自身能力。 主要模式： 單人模式：玩家與精心設計的AI進行對戰。 雙人模式：兩位玩家進行本機對戰。 初始條件： 每位玩家擁有3條初始生命值。一旦被炸彈爆炸波及，即損失一條生命。生命值歸零則玩家被淘汰。若雙方同時失去所有生命，則判定為平局。 結束條件： 任一方玩家生命值耗盡，或遊戲時間結束。 2.2 道具系統 多樣的道具為遊戲增添了策略性與變數： 增加玩家分數： 綠色星星 (★) 增加玩家生命： 紅色愛心 (♥) 增加同時放置炸彈數量上限： 黑桃 (♠) 增加炸彈爆炸範圍： 黑色齒輪 (❁) 2.3 計分規則 玩家的得分主要基於以下行為： 擊敗對手： 成功使用炸彈擊中對手，獲得100分獎勵。 收集道具： 加分道具 (綠色星星★)：每個增加50分。 其他功能性道具 (增加生命、炸彈數、爆炸範圍)：每個增加20分。 存活時間： 遊戲結束時，存活時間將作為排行榜上區分同分玩家的額外依據。 2.4 地圖設計與爆炸機制 地圖種類： 遊戲提供三種地圖：簡易版、中等版，以及隨機生成障礙物的困難版。地圖由固定障礙物、可破壞障礙物、道具及空地構成。 爆炸機制： 玩家炸彈的初始爆炸範圍為3格。爆炸時，路徑上的可摧毀障礙物（Destructible Obstacles）會被清除，並有機率掉落道具。收集到「範圍增加道具（❁）」可使炸彈爆炸範圍額外增加1格。 三、架構與核心功能實現 3.1 專案模組化：檔案結構與職責劃分 為了實踐模組化與物件導向的設計理念，我們將專案的程式碼拆分為13個檔案，包含標頭檔 (.h)、原始碼檔 (.cpp) 以及純文字資料檔 (.txt)，各司其職。 3.1.1 遊戲核心邏輯 ( / ) 負責遊戲的整體流程控制，包括初始化、主遊戲循環、炸彈管理、勝負判斷以及玩家狀態（分數、生命）的維護。 主要函數： * * 3.1.2 AI 玩家控制邏輯 ( / ) 此模組是AI玩家的“大腦”，採用有限狀態機 (Finite State Machine, FSM) 進行決策，並結合廣度優先搜索 (BFS) 演算法進行路徑規劃。 FSM狀態定義 ()： 核心決策函數 ()： 函數根據當前遊戲局勢，依照預設的優先級（如躲避優先於攻擊）來切換AI狀態。 路徑規劃函數 ()： 實現了BFS演算法，用於計算到達目標點的最短路徑。 其他狀態處理函數：, , 等。 3.1.3 遊戲物件管理 ( / ) 作為遊戲內核心物件（玩家、炸彈等）的基礎，並管理排行榜數據及底層終端機I/O。 主要函數：, , , 。 3.1.4 使用者介面 ( / ) 負責主選單、地圖選擇、ASCII動畫等視覺呈現與互動。 主要函數：, , 。 3.1.5 全域變數與設定 ( / ) 集中存儲地圖尺寸、遊戲符號、控制鍵等全域參數。 3.1.6 純文字資料檔 ( / ) 分別用於持久化存儲排行榜數據和ASCII動畫內容。 3.2 物件導向程式設計 (OOP) 的實踐 物件導向是本專案的核心設計思想。透過封裝 (Encapsulation) 與繼承 (Inheritance)，我們有效地提升了程式碼的模組化程度、可維護性與擴展性。 基礎類別 ()： 繼承結構 (, )： 這樣的繼承關係（亦繼承自）構建了清晰的類別層次，實現了程式碼的複用與功能的專注。 權限控制與依賴管理： 透過 , , 控制成員可見性，並以 管理模組間依賴。 3.3 程式執行流程 遊戲的整體執行流程清晰明瞭，從初始化、選單互動到主遊戲循環，最終進行結果判定。為了編譯方便，我們使用技術，大大降低編譯與執行的複雜性。 圖五：程式執行流程圖 (示意圖，請替換為您的圖片) 四、特色功能深度剖析 除了完成基礎遊戲框架，我們亦投入心力於以下特色功能的實現，並克服了開發過程中的挑戰： 4.1 隨機地圖生成與平衡性考量 為提升遊戲的重玩價值，我們設計了隨機地圖生成演算法。 核心挑戰： 如何避免玩家初始位置被障礙物完全封鎖。 解決方案： 引入「玩家保護區」機制，確保玩家初始點周圍3x3區域的通暢。同時，透過機率控制障礙物和道具的整體分佈，以維持地圖的平衡性與趣味性。 道具生成策略： 可破壞障礙物被摧毀後，有高機率（80%）生成道具，各類道具（加分、加生命、加炸彈數、加範圍）亦有其獨立的出現機率。 圖六：隨機地圖中的玩家初始保護區 (示意圖) 4.2 使用者互動介面 (UI/UX) 優化 良好的UI/UX是提升遊戲沉浸感的關鍵。我們著重於選單系統的易用性，並手動編寫了ASCII藝術風格的開場、勝利等動畫效果，力求在純C++文字環境下提供最佳的視覺與互動體驗。排行榜功能也為玩家提供了持續挑戰的目標。 4.3 AI 智能核心：有限狀態機 (FSM) 與 BFS 演算法的融合 AI 的設計是本專案最具挑戰性也最富成就感的部分。 演進過程： 從最初基於簡單規則的反應式AI，演進到採用有限狀態機 (FSM) 進行宏觀決策，結合BFS進行微觀路徑規劃的策略。 FSM 設計： AI定義了五種核心狀態（ESCAPE, WAIT_EXPLOSION, FETCH_ITEMS, ATTACK_PLAYER, IDLE）。 函數作為AI的決策中樞，根據當前戰局的優先級（例如，躲避危險 > 攻擊玩家 > 拾取道具）來觸發狀態轉換。 BFS 應用： 在每個決策狀態下，AI利用BFS快速計算到達目標（安全點、道具、敵方玩家）的最短無障礙路徑，並能動態避開已知的炸彈爆炸區域。 技術亮點： 即時決策與反應： FSM與BFS的結合使得AI能夠在快速變化的遊戲環境中迅速做出反應。 策略性避險： AI能主動識別並規避潛在危險。 多目標路徑規劃： BFS能夠靈活應對不同狀態下的多樣化路徑尋找需求。 AI 狀態轉換邏輯概要 （此處可保留或精簡您報告中關於各狀態進入與離開條件的詳細文字描述，或者用更簡潔的表格/列表呈現關鍵的轉換邏輯。） | 狀態 (State) | 主要行為 (Action) | 觸發進入條件 (Transition In) | 優先離開條件 (Transition Out to Higher Priority) | | :--------------- | :------------------------- | :------------------------------- | :--------------------------------------------- | | ESCAPE | 逃離炸彈，尋找安全點 | 偵測到自身處於炸彈爆炸範圍內 | - (最高優先級) | | WAIT_EXPLOSION | 在安全區等待自己放置的炸彈爆炸 | 剛放置炸彈且已移動到安全位置 | ESCAPE (若出現新威脅) | | ATTACK_PLAYER | 追蹤並嘗試攻擊人類玩家 | 偵測到玩家且無立即危險 | ESCAPE | | FETCH_ITEMS | 移動並拾取地圖上的道具 | 偵測到道具且無更高優先級任務 | ESCAPE, ATTACK_PLAYER | | IDLE | 在地圖上巡邏或隨機移動 | 無任何上述高優先級任務執行 | ESCAPE, ATTACK_PLAYER, FETCH_ITEMS | 表二：AI核心狀態及其轉換優先級簡表 五、專案總結與技術反思 這次「瘋狂炸彈人」的專案開發是一次深刻的學習與實踐之旅。從最初的遊戲概念構想到最終的成品，我們不僅深化了對C++語言和物件導向程式設計的理解，更在演算法應用（特別是FSM和BFS在AI設計中的整合）、系統模組化、以及專案管理方面獲得了寶貴的經驗。 核心技術挑戰與突破： AI智能設計： 從規則式AI到引入FSM進行情境判斷與策略切換，是提升AI「智慧感」的關鍵。如何定義合理的狀態、設計精確的轉換條件，並讓AI在不同狀態下表現出符合邏輯的行為，是我們反覆調試和優化的重點。BFS演算法的引入，則有效解決了AI在複雜地圖中的路徑規劃難題。 物件導向實踐： 隨著專案規模的擴大（最終程式碼超過2000行），物件導向的優勢愈發凸顯。將遊戲元素（玩家、炸彈、地圖、AI控制器、選單等）抽象為類別，並透過封裝、繼承來組織程式碼，極大地提高了程式的可讀性、可維護性和擴展性。例如，AI控制器繼承自通用的遊戲物件，使得AI可以方便地獲取遊戲狀態，同時其自身的邏輯又保持了獨立性。 除錯與迭代： 大規模程式的除錯無疑是一項艱鉅的任務。我們深刻體會到模組化設計對於定位和修復bug的重要性。不斷的測試、反饋和迭代優化，是專案得以順利完成並達到預期效果的保證。 個人成長與啟示： 這個專案不僅僅是一份課程作業，它更像是一次小型軟體工程的演練。從需求分析、系統設計、編碼實現到測試除錯，我們經歷了軟體開發的完整週期。廢寢忘食地投入、與組員的密切協作、以及最終看到親手打造的AI在遊戲中展現出預期行為時的成就感，都成為了寶貴的記憶。 FSM的設計雖然直觀，但在面對更動態和不確定的環境時，其狀態的定義和轉換邏輯會變得非常複雜。這次的經驗也啟發我去思考未來如何引入更具適應性的AI技術，例如強化學習的初步概念，來應對更複雜的決策場景。 更重要的是，透過這個專案，我更加確信了自己對軟體邏輯建構與演算法設計的濃厚興趣。能夠將抽象的理論知識轉化為實際可運行的、能與人互動的智慧系統，這種創造過程本身充滿了魅力。未來，我期望能在此基礎上，向更複雜的AI系統、更精巧的演算法設計以及更大型的軟體工程專案發起挑戰。","codeText":"GameCrazyArcade.h GameCrazyArcade.cpp gameInitialization(Player, Player) drawGame(Player, Player, GameObject) updateBombs(Player, Player, GameObject) GameStart(Player, Player, GameObject, Menu) AIController.h AIController.cpp AIController.h     // AIController.h (片段) - AI 狀態枚舉\n    enum class AIState {\n        ESCAPE,         // 逃避炸彈\n        WAIT_EXPLOSION, // 等待爆炸結束\n        FETCH_ITEMS,    // 拾取道具\n        ATTACK_PLAYER,  // 攻擊玩家\n        IDLE,           // 閒置巡邏\n    };\n     AIController.cpp updateState     // AIController.cpp (片段) - updateState 核心邏輯簡化示意\n    void AIController::updateState(Player &computerPlayer, Player &humanPlayer) {\n        // ... (計算炸彈是否活躍等前置判斷) ...\n\n        // Priority 1 : ESCAPE or WAIT_EXPLOSION\n        if (isBombActiveAndNear()) {\n            if (canEscapeToSafeCell()) {\n                if (currentState != AIState::ESCAPE) startState(AIState::ESCAPE);\n                return;\n            } else {\n                if (currentState != AIState::WAIT_EXPLOSION) startState(AIState::WAIT_EXPLOSION);\n                return;\n            }\n        }\n\n        // Priority 2 : ATTACK_PLAYER\n        if (canAttackPlayer(humanPlayer)) {\n            if (shouldPlaceBombToAttack(computerPlayer, humanPlayer)) {\n                placeBombSafely(computerPlayer);\n                startState(AIState::ESCAPE); // or WAIT_EXPLOSION after placing bomb\n                return;\n            } else {\n                if (currentState != AIState::ATTACK_PLAYER) startState(AIState::ATTACK_PLAYER);\n                // ... (設置攻擊路徑) ...\n                return;\n            }\n        }\n        // Priority 3 : FETCH_ITEMS (省略部分邏輯)\n        // ...\n\n        // Default : IDLE\n        if (currentState != AIState::IDLE) startState(AIState::IDLE);\n    }\n     AIController.cpp bfsFindPath     // AIController.cpp (片段) - bfsFindPath 核心結構示意\n    vector<pair<int,int>> AIController::bfsFindPath(const Player &start, const vector<pair<int,int>> &targets, bool avoidDanger){\n        auto dangerMap = computeDangerMap(); // 計算當前危險區域\n        vector<vector<bool>> visited(mapHeight, vector<bool>(mapWidth,false));\n        vector<vector<pair<int,int>>> parent(mapHeight, vector<pair<int,int>>(mapWidth, {-1,-1}));\n        queue<pair<int,int>> q;\n\n        q.push({start.y,start.x});\n        visited[start.y][start.x] = true;\n\n        // BFS 主體邏輯：擴展節點，記錄父節點，直到找到目標或佇列為空\n        // ... (省略了標準的BFS佇列操作、鄰居節點遍歷檢查、邊界與障礙物判斷等) ...\n\n        // 回溯路徑 (Path reconstruction)\n        if (foundTarget) {\n            vector<pair<int,int>> path;\n            pair<int,int> curr = foundTargetCell;\n            while (!(curr.first == start.y && curr.second == start.x)) {\n                path.push_back(curr);\n                curr = parent[curr.first][curr.second];\n            }\n            path.push_back({start.y,start.x}); // 加入起點\n            reverse(path.begin(),path.end());\n            path.erase(path.begin()); // 移除路徑中的第一個元素 (即AI當前位置)\n            return path;\n        }\n        return {}; // 未找到路徑\n    }\n     handleEscapeState handleAttackPlayerState handleFetchItemsState GameObject.h GameObject.cpp loadLeaderboard updateLeaderboard displayLeaderboard setConioTerminalMode Menu.h Menu.cpp initial_animation Display_Main_Menu Map_Selection Globals.h Globals.cpp leaderboard.txt animation.txt GameObject.h     // GameObject.h (片段) - 基礎類別定義\n    class GameObject {\n    protected:\n        struct Bomb { /* ... Bomb 結構定義 ... */ };\n        vector<Bomb> bombs;\n    public:\n        struct Player { /* ... Player 結構定義 ... */ };\n        // ... 其他通用方法與成員 ...\n    };\n     AIController.h GameCrazyArcade.h     // AIController.h (片段) - 繼承 GameObject\n    #include \"GameObject.h\"\n    class AIController : public GameObject { /* ... AI特定成員與方法 ... */ };\n\n    // GameCrazyArcade.h (片段) - 繼承 AIController\n    #include \"AIController.h\"\n    class GameCrazyArcade : public AIController { /* ... 遊戲主邏輯方法 ... */ };\n     Menu GameObject public protected private #include makefile updateState()","mathText":"","category":"遊戲開發","tags":"C++ 遊戲開發 AI FSM BFS 物件導向 期末專題 瘋狂炸彈人","url":"/cpp-crazy-arcade-ai","slug":"cpp-crazy-arcade-ai"},{"id":1,"title":"最近點對：詳解4種不同複雜度之算法","date":"2025-05-12T00:00:00.000Z","plainText":"題目敘述 給定二維平面上 個點，每一點都有座標 ，求出最近的點對之歐幾里德距離為多少？ 平面最近點對有好多種實作方式，從最差的暴力枚舉、稍微優化的掃描線演算法、到分治與隨機，有4種不同的時間複雜度。利用TIOJ 1500這一題最近點對的裸題，來實測各種不同複雜度下所需要的執行時間。 暴力枚舉 時間複雜度： Submission 時間：TLE,10440 暴力將所有點進行枚舉，因為值域是 ，平方枚舉會有TLE的問題。 程式碼 掃描線算法 時間複雜度：Worst Case Submission 時間：AC,1668 這一種作法是改善過後的暴力枚舉，利用計算幾何中掃描線的概念，先將所有點依照x座標進行排序（y座標隨意）。接著想像一條從左往右掃的掃描線，對於每一條掃描線看右邊的點，如果當前最近點對距離為 ，因此只要遇上x座標差距大於 的點時，即可繼續下一輪的枚舉。 加上排序的關係，其時間複雜度至少為 ，但這種掃描線的方式無法有效過濾所有點都在相同的x座標上的情況，因此最差的時間複雜度會退化成 ，不過聽說平均的狀況下是很快的！ 上圖為掃描線執行最近點對的一個示意圖，黑線為掃描線， 為掃描線左邊所有點的最近點對距離，我們只要每一輪枚舉這個點與右邊x座標差在 以內的所有點，即可進行下一輪的更新！ 程式碼 掃描線算法（優化後） 時間複雜度： Submission 時間：AC,148 原本以為上面的掃描線就是他的極限了，沒想到上面的worst case還可以透過set優化成 ！簡單來說，方法一樣是想像一條掃描線由左而右，一樣照上面的想法，把x座標差大於d的點排除，之後利用set二分搜找出y座標在範圍內的點進行枚舉更新答案。 實作步驟 將點輸入並且排序，X座標為主，Y座標為輔。 使用set，並以Y座標為排序基準（pair的首項），以儲存第 點的左方、水平距離小於等於d的點。 右掃描線依序窮舉各點作為右端點。 (1) Erase與右端點水平距離大於d的點們（左掃描線右移） (2) 用二分搜找出與第 點垂直距離小於d的點，並嘗試更新 (3) 將第 點加入set中。 程式碼 分治算法 時間複雜度： Submission 時間：AC,196 分治做最近點對的基本想法，先將所有點依照x座標排序，利用遞迴得到分割點左右兩邊所有點的最短距離（兩點並不會跨過中間分隔線），枚舉所有會橫跨兩側且有可能更新最短距離的點對。 從兩半邊的遞迴得到目前的最近點對距離 ，將分隔線附近x座標差距小於的點通通都枚舉一遍。可能會有一個疑問，我們是不是可以縮小枚舉的範圍，否則點的數量可能會太多導致複雜度爆炸？除了x座標可以做點的篩選之外，在枚舉的過程中，我們會利用將所有點對y座標排序，將y座標直線距離大於 的情況剔除，所剩下真的需要枚舉點也只會剩下常數個，因此可以放心枚舉。 複雜度分析： 腦海中想像遞迴樹的長相，會發現每一層都需要都需要對y座標進行排序，時間為 ，每一次都將n的值除以2，因此共有 層，總共的時間複雜度為 。（不過實際上應該會比這個快，因為並不是要對所有點都進行排序）。 如果要做得更快，可以在y座標排序的地方稍微動動手腳。既然每一層都要對y座標進行排序，排序好的東西再排序一次其實沒有什麼意義，因此就可以用）合併排序（merge sort）的方式，將所有已經排序好的兩個左右序列進行的合併（可以用std::merge()完成），如此一來，就不須要每一層花到 的ㄕˊ間進行排序，使總複雜度降低為 ！ 程式碼 隨機算法 時間複雜度：期望 Submission 時間：AC,488 用隨機算法做最近點對的期望複雜度是 ，也就是說如果一開始進行的Random_shuffle有做好的話，期望可以在線性時間解決這個問題。基本的想法如下： 實作步驟 將最近點對距離設為d，初始為第一、二個點之間的距離 將每一個點的座標塞入以 為邊長的網格中 將點加入網格中，查看要加入的網格是否已經有點在其中 一個網格不可容納兩個點，否則必須更新最近點對的距離 在更新最近點對距離之後，將前面的點的網格座標以新的進行更新 這個算法用到隨機的因子，因此如果在一開始有將所有點進行均勻的打散的話，可以做到期望複雜度 。 複雜度分析： 考慮加入第i+1個點時出現新的最近點對，發生的機率為：在個配對中跟i+1個點產生最近點對共有i種可能因此機率為。 當機率發生的時候，必須將所有的點都刪掉重新來一遍（r變小，重新推入i+1個點），需要付出的時間，相乘起來加入每一個點期望的複雜度為，因此總時間複雜度為。 程式碼 相關題目 NEOJ 最近點對 TIOJ 最遠點對","codeText":"#include <bits/stdc++.h>\n#define Orz ios::sync_with_stdio(0),cin.tie(0)\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define pii pair<int,int>\n#define pdd pair<double,double>\n#define int long long\n#define ll long long\n#define ld long double\n#define N 50005\n#define all(x) x.begin(),x.end()\n#define INF 5e18\n#define eps 1e-9\n#define x first\n#define y second\nusing namespace std;\nint n;\npii p[N];\n\nld dis(pii a, pii b){\n    ld x = a.x-b.x, y = a.y-b.y;\n    return sqrt(x*x + y*y);\n}\n\nsigned main(){\n    Orz;\n    cout<<fixed<<setprecision(6);\n    \n    while(cin>>n){\n        rep(i,0,n-1)cin>>p[i].x>>p[i].y;\n        ld d = INF;\n        rep(i,0,n-1){\n            rep(j,i+1,n-1){\n                d = min(d, dis(p[i],p[j]));\n            }\n        }\n        cout<<d<<endl;\n    }\n}\n #include <bits/stdc++.h>\n#define Orz ios::sync_with_stdio(0),cin.tie(0)\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define pii pair<int,int>\n#define pdd pair<double,double>\n#define int long long\n#define ll long long\n#define ld long double\n#define N 50005\n#define all(x) x.begin(),x.end()\n#define INF 5e18\n#define eps 1e-9\n#define x first\n#define y second\nusing namespace std;\nint n;\npii p[N];\n\nld dis(pii a, pii b){\n    ld x = a.x-b.x, y = a.y-b.y;\n    return sqrt(x*x + y*y);\n}\n\nsigned main(){\n    Orz;\n    cout<<fixed<<setprecision(6);\n    \n    while(cin>>n){\n        rep(i,0,n-1)cin>>p[i].x>>p[i].y;\n        sort(p,p+n);\n        ld d = INF;\n        rep(i,0,n-1){\n            rep(j,i+1,n-1){\n                if(p[j].x > p[i].x + d)break;\n                d = min(d, dis(p[i],p[j]));\n            }\n        }\n        cout<<d<<endl;\n    }\n}\n #include <bits/stdc++.h>\n#define int long long\n#define ld long double\n#define N 200005\n#define x first\n#define y second\n#define pii pair<int,int>\n#define IOS ios::sync_with_stdio(0),cin.tie(0)\nusing namespace std;\nint n;\nvector<pii> p;\nset<pii> s;\n\nld dis(pii a, pii b){\n    ld x = a.x-b.x, y = a.y-b.y;\n    return sqrt(x*x + y*y);\n}\n\nsigned main(){\n    IOS;\n    cout<<fixed<<setprecision(6);\n    while(cin>>n){\n        p.assign(n,{0,0});\n        for(int i = 0;i < n;i++)cin>>p[i].x>>p[i].y;\n        sort(p.begin(),p.end());\n        s.clear();\n        s.insert({p[0].y,p[0].x});\n        int l = 0;ld ans = 5e18;\n        for(int i = 1;i < n;i++){\n            int d = ceil(ans);\n            while(l < i && p[l].x < p[i].x - d){\n                s.erase({p[l].y,p[l].x});\n                l++;\n            }\n            auto it_l = s.lower_bound({p[i].y - d,0});\n            auto it_r = s.upper_bound({p[i].y + d,0});\n            for(auto it = it_l;it != it_r;it++){\n                ans = min(ans,dis({it->y,it->x},p[i]));\n            }\n            s.insert({p[i].y,p[i].x});\n        }\n        cout<<ans<<endl;\n    }\n}\n #include <bits/stdc++.h>\n#define ll long long\n#define int long long\n#define double long double\n#define Orz ios::sync_with_stdio(0),cin.tie(0)\n#define N 50002\n#define INF1 100000000\n#define INF 5e18\n#define FOR(i,n) for(int i=0;i<n;i++)\n#define rep(i,l,r) for(int i=l;i<=r;i++)\n#define pii pair<int,int>\n#define x first\n#define y second\n#define pid pair<int,double>\n#define pdi pair<double,int>\n#define pdd pair<double,double>\nusing namespace std;\nint n;\nvector<pii> p,temp;\n\nvoid init(){\n    cout<<fixed<<setprecision(6);\n    temp.clear();\n    p.assign(n,{0,0});\n}\n\nbool cmp(pii a,pii b){\n    return a.y < b.y;\n}\n\ndouble dis(pii a,pii b){\n    double x1 = a.x-b.x,y1 = a.y-b.y;\n    return sqrt(x1 * x1 + y1 * y1);\n}\n\n//區間[l,r]\ndouble solve(int l,int r){\n    if(l == r)return INF;\n    int mid = (l+r)/2,mid_pos = p[mid].x;;\n    double ans = min(solve(l,mid),solve(mid+1,r));\n    \n    temp.assign((r-l+1),{0,0});\n    merge(\n        p.begin() + l, p.begin() + mid + 1,\n        p.begin() + mid + 1, p.begin() + r + 1,\n        temp.begin(), cmp\n    );\n    rep(i, l, r)p[i] = temp[i-l];\n    temp.clear();\n    rep(i, l, r){\n        if(abs(p[i].x - mid_pos) <= ans){\n            temp.push_back(p[i]);\n        }\n    }\n    int len = temp.size();\n    rep(i, 0, len-1){\n        rep(j, i+1, len-1){\n            ans = min(ans, dis(temp[i],temp[j]));\n            if(abs(temp[i].y-temp[j].y) > ans)\n                break;\n        }\n    }\n    return ans;\n}\n\nsigned main(){\n    Orz;\n    while(cin>>n){\n        init();\n        rep(i,0,n-1)cin>>p[i].x>>p[i].y;\n        sort(p.begin(),p.end());\n        double ans = solve(0,n-1);\n        cout<<ans<<endl;\n    }\n}\n #include <bits/stdc++.h>\n#define int long long int\n#define ld long double\n#define ios ios::sync_with_stdio(0),cin.tie(0)\n#define N 200005\n#define INF 1000000000LL\n#define swift 1000000000\nusing namespace std;\nint n;\nld r,d,ans;\nint dx[25] = {-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2};\nint dy[25] = {-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2};\nunordered_map<int, int> m;\n\nvoid solve();\ninline void init();\nvoid solve();\nbool insert(int,int,int);\ninline double dis(int,int);\ninline int Grid(int);\n\nstruct node{\n    int x,y,ind;\n}point[N];\n\n//函式實作\ninline void init(){\n    m.clear();\n    cout<<fixed<<setprecision(6);\n}\n\ninline int Grid(int ind){ //input網格座標\n    int x = point[ind].x/r;\n    int y = point[ind].y/r;\n    return x*INF+y;\n}\n\ninline ld dis(node a,node b){\n    ld x = a.x-b.x,y = a.y-b.y;\n    return sqrt(x*x+y*y);\n}\n\nvoid solve(){\n    m.insert(make_pair(Grid(0),0));m.insert(make_pair(Grid(1),1));\n    for(int ind = 2;ind < n;ind++){\n        int x = point[ind].x/r,y = point[ind].y/r,better=0;\n        for(int i=0;i<25;i++){\n            int nx = x+dx[i],ny = y+dy[i];\n            auto it = m.find(nx*INF+ny);\n            if(it!=m.end()){\n                double distance = dis(point[it->second],point[ind]);\n                if(distance<d){\n                    better = 1;\n                    ans = dis(point[it->second],point[ind]);\n                    d = distance;\n                    r = d/2;\n                }\n            }\n        }\n        if(better){\n            m.clear();\n            for(int i=0;i<=ind;i++)m.insert(make_pair(Grid(i),i));\n        }\n        else{\n            m.insert(make_pair(Grid(ind), ind));\n        }\n    }\n}\n\nsigned main(){\n    ios;\n    while(cin>>n){\n        init();\n        for(int i=0;i<n;i++){\n            int x,y;cin>>x>>y;\n            x+=swift;y+=swift;\n            point[i].x = x;point[i].y = y;\n        }\n        random_shuffle(point, point+n);\n        int smalln = sqrt(n);\n        ans = dis(point[0],point[1]);\n        d = dis(point[0], point[1]);\n        for(int i=0;i<=smalln;i++){\n            for(int j=i+1;j<=smalln;j++){\n                d = min(d,dis(point[i], point[j]));\n                ans = min(ans,dis(point[i],point[j]));\n            }\n        }\n        r = d/2;\n        solve();\n        cout<<ans<<endl;\n    }\n}\n","mathText":"n (x_i,y_i) dis(p_i,p_j) = \\sqrt{(x_1-x_2)^2+(y_1-y_2)^2} O(N^2) O(n^2) n≤50000 O(N^2) d d O(n\\log n) O(n^2) d d O(N\\log N) O(n\\log n) i i i O(N\\log N) d = min(d_l,d_r) d d O(n\\log n) O(\\log n) O(n\\log^2n) T(n) = 2T(\\frac{n}{2})+O(n\\log n) = O(n\\log^2n) O(n) O(n\\log n) O(n\\log n) T(n) = 2T(\\frac{n}{2})+O(n) = O(n\\log n) O(N) O(n) \\frac{d}{2} d O(n) C_2^{i+1} \\frac{2}{i+1} O(i+1) O(1) O(n)","category":"演算法","tags":"演算法 分治法","url":"/pair","slug":"pair"},{"id":2,"title":"Pycade Bomber：用 Python 打造智慧 AI 與 CI/CD 開發流程的 Pygame 專案","date":"2025-06-09T00:00:00.000Z","plainText":"1. 前言：不只是一個遊戲，更是一次軟體工程的開發實踐 Crazy Arcade 是我大一上計算機概論的期末專題，那時我用 C++ 實作出具有基礎 FSM 的動態策略電腦玩家的模型，開發帶有道具、計分版、隨機地圖等功能的遊戲專案，獲得不錯的評價！ 為了追求更豐富的視覺體驗、更智慧的 AI 對手，以及更貼近業界標準的開發流程，我們決定近一步延伸上學期專案的內容，以 Python 語言時實作 Pycade Bomber 專案，使用 Python 與 Pygame 的將遊戲質感提升一個層次！ 這篇文章將不僅僅是展示遊戲成果，更是一份詳細的開發日誌。我們將深入拆解專案背後的三大核心： 穩健的物件導向架構 (OOP)：如何打造一個易於維護與擴充的遊戲世界。 多策略的智慧 AI (FSM)：如何設計出擁有多種「個性」、會思考、懂戰術的 AI 對手。 業界級的自動化流程 (CI/CD)：如何透過自動化測試與部署，確保程式碼品質並能一鍵發佈。 在開始之前，何不先親身體驗一下？ 👉 馬上試玩：Pycade Bomber 線上遊戲連結 👉 查看原始碼：GitHub 專案連結 技術棧 (Tech Stack): , , , , , , , , 2. 專案的藍圖：穩健的物件導向架構 一個好的遊戲，底層必然有一個穩健的架構。隨著專案規模擴大（我們的專案超過 5,000 行程式碼），混亂的結構會導致開發效率低落與無盡的 bug。為此，我們在專案初期就導入了物件導向程式設計 (OOP) 的核心思想，並透過以下幾個方面來實踐： 2.1 關注點分離 (Separation of Concerns) 我們將專案的不同職責，劃分到獨立的模組中，讓每個部分都專心做好自己的事。 ：負責遊戲的核心運作邏輯，例如場景管理 ()、AI 控制器 ()、資源管理器 () 等。 ：定義所有遊戲中看得到的實體物件，例如玩家 ()、炸彈 ()、牆壁 () 等。 ：存放所有靜態資源，包含圖片、音效、字體和地圖資料。 ：存放所有使用 Pytest 編寫的單元測試，確保每個模組的正確性。 點此查看更完整詳盡的 Class Diagram 此外，我們將所有全域設定（如顏色、速度、視窗尺寸）集中在 中管理，避免了「魔法數字」(Magic Numbers) 的出現，讓專案配置一目了然。 2.2 封裝的力量 (Encapsulation) 「封裝」是將複雜的內部實作「包裝」起來，只對外提供簡單易用的操作介面。 是這個理念的最佳範例。 主程式 () 不需要知道 如何初始化、如何載入音效檔案、如何管理音軌。它只需要呼叫一個簡單的方法： 所有複雜的細節都被隱藏在 內部。未來若要更換音效引擎，也只需要修改這個類別，完全不會影響到主程式的任何一行程式碼。 2.3 繼承與策略模式 (Inheritance & Strategy Pattern) 我們透過「繼承」來建立通用的物件樣板，減少重複的程式碼。例如，、、 等所有遊戲物件都繼承自一個通用的 類別，共享 和 等基本屬性。 但更進一步，我們運用了「策略模式」來設計 AI 的多種「個性」。 我們首先定義了一個 作為所有 AI 都必須遵守的通用介面（策略的抽象）。接著，、 等子類別各自繼承此介面，並發展出獨特的頂層目標（具體的策略實現）。 這種設計的最大好處是「高內聚、低耦合」。遊戲主體不需要關心 AI 的內部決策邏輯，只需要在遊戲開始前，像插拔卡帶一樣，將指定的 AI 控制器「安裝」到角色上即可。這使得新增或修改 AI 行為變得非常容易，而不會影響到遊戲的其他部分。 2.4 場景管理與狀態模式：以暫停介面為例 一個完整的遊戲不僅有核心玩法，還需要選單、暫停、結束畫面等多個「場景」。如何優雅地在這些場景間切換，同時管理它們各自的狀態，是軟體架構的一大考驗。我們的「暫停介面」就是狀態模式與場景管理思想的具體實踐。 挑戰：當玩家按下 鍵時，如何讓整個遊戲世界（玩家移動、AI 運算、炸彈倒數）瞬間「凍結」，並疊加上一個獨立的暫停選單？ 架構設計：我們將 主場景和 視為兩個獨立的物件。 Game 物件：作為一個「狀態管理者」，它內部有一個 旗標。它的主迴圈會根據此旗標，決定是執行完整的遊戲更新邏輯，還是將控制權交給 物件。 PauseScene 物件：這是一個完全獨立的場景，它只負責繪製自己的半透明背景和按鈕，並處理自己的點擊事件。它不需要知道任何關於玩家或炸彈的細節，實現了高度的「職責分離」。 當遊戲暫停時， 物件會實例化一個 ，並巧妙地將自己 () 傳遞給它。這樣一來， 就能在玩家點擊「繼續遊戲」時，反過來呼叫 物件的 方法來改變 狀態，從而交還控制權。 這種設計避免了在遊戲主迴圈中寫入大量 的混亂邏輯，讓每個場景各司其職，大幅提升了程式碼的清晰度與可維護性。 3. AI 的靈魂：多策略 FSM 決策系統 如果說穩健的架構是專案的骨架，那麼智慧的 AI 則是專案的靈魂。我們的目標是創造出不像機器人、懂得審時度勢、甚至會設下陷阱的對手。為此，我們融合了幾種核心技術，打造出 AI 的決策大腦。 3.1 有限狀態機 (FSM) - AI 的決策大腦 我們為每個 AI 導入了「有限狀態機」(Finite State Machine, FSM)。這相當於 AI 的決策中樞，它會根據當前的戰場局勢，在不同的「狀態」之間進行切換，從而做出最合適的行為。 例如，AI 的核心狀態包括： **：最高優先級。當偵測到自己位於炸彈的爆炸範圍內時，拋下一切任務，立刻尋找安全路徑逃離。 **：放置炸彈後，不呆在原地，而是戰術性地撤退到安全位置，等待爆炸成果。 **：搜尋地圖上的道具，規劃路徑去拾取以增強自身實力。 **：主動追擊玩家，並試圖在適當的位置放置炸彈進行攻擊。 **：終局模式。當地圖上的障礙物被清空時，AI 會變得極具攻擊性，對玩家展開最終狩獵（針對道具型模式）。 3.2 智慧尋路演算法 (A* / BFS) - AI 的行動指引 當 FSM 決定了「目標」（要去哪裡）之後，AI 需要一條聰明的路徑來達成目標，而不是一頭撞上牆。為此，我們在 AI 內部實作了 A\\* 與 BFS 兩種經典的路徑規劃演算法。 A\\* 演算法：用於計算前往遠距離目標（如玩家或特定道具）的最佳路徑，它會綜合考慮已走過的路徑成本與到終點的預估成本。 BFS 演算法：用於尋找鄰近最快可達的目標，它不考慮成本，只求以最少步數到達，非常適合用於戰術性的快速移動，例如逃離危險。 在我們的實作中，我們選擇了最經典且高效的方式來實現這兩種演算法： 對於 BFS，我們利用 Python 的 作為佇列 (Queue)，它提供了高效的 append 和 popleft 操作。我們透過一個 集合 (Set) 來記錄已訪問過的節點，以避免在圖中走回頭路或陷入無限迴圈。 對於 A\\，其核心在於它的評估函數 。我們使用了一個優先佇列 (Priority Queue)* 來存放待探索的節點，確保每次都能選出 值最小的節點進行探索。其中： 是從起點到目前節點的實際移動成本（步數）。 是我們設計的啟發函數 (Heuristic Function)，我們採用了「曼哈頓距離 (Manhattan Distance)」，因為在我們這種只能上下左右移動的網格地圖中，它能非常快速且準確地估計到終點的距離。 我們根據任務的不同，來決定使用哪種演算法——需要快速找到鄰近安全點時用 BFS，需要規劃長遠的攻擊或奪寶路徑時用 A\\。這種針對性的選擇，是我們在專案中對演算法效率與場景應用的 *權衡（Trade-off）** 與實踐。 為了讓玩家能更直觀地感受到 AI 的「思考」，我們在遊戲畫面的右下角即時顯示出 AI 當前的狀態。如圖所示，當 AI 玩家鎖定場上的道具後，會使用 A* 演算法尋找一條成本最低的路徑，並且在放置炸彈清除障礙物後，使用 BFS 尋找鄰近的安全撤退位置，並切換到「戰術性撤退」狀態躲避並等待炸彈爆炸。 如下圖，AI 道具型玩家鎖定場上出現的道具，利用 A* 規劃一條通往道具的路徑（如藍線），並放置炸彈清除路徑上的障礙物，並在放完炸彈後用 BFS 尋找附近的安全區躲避（如綠線），等待爆炸。 3.3 AI 的多種「個性」 為了提升遊戲的重玩價值與挑戰性，我們設計了多種不同行為模式的 AI 對手，玩家可以在主選單自由選擇。 | AI 類型 | 主要行為模式 | 特點 | | :---- | :---- | :---- | | 道具型 | 專注於獲取道具，強化自身 | 在遊戲前期會優先吃道具，等裝備成形後轉為攻擊性，最具挑戰性。 | | 攻擊型 | 積極追擊和攻擊玩家 | 以消滅玩家為最主要目標，會想盡辦法將玩家逼入死角。 | | 保守型 | 行為謹慎，優先自保 | 會盡量避開交火區，在安全的狀況下才放置炸彈，較容易對付。 | | 標準型 | 基礎的 AI 行為模式 | 行為較均衡，也是我們最先開發的模型（基本款）。是玩家熟悉遊戲機制的最佳練習對象。 | 4. 學習業界標準的開發與協作流程 一個成功的專案，不僅仰賴優雅的程式碼，更仰賴一套清晰、高效且可靠的開發與協作流程。我們參照業界標準，建立了結合「人工智慧」與「自動化」的完整管線，確保從開發、審查到最終部署的每一步都在掌控之中。這讓我們與其他課程專案最大的不同之處。 4.1 分支管理策略 (Branching Strategy) 為了保護 分支（代表了隨時可以部署的「正式版」）的絕對穩定，我們採用了以下策略： 禁止直接提交 (No Direct Push)：協作者不能直接將程式碼推送到 分支。 功能分支 (Feature Branch)：每當要開發一個新功能 (如 ) 或修復一個錯誤 (如 )，都必須從最新的 分支建立一個新的獨立分支。所有開發工作都在這個獨立的分支上進行，與主線完全隔離，確保不會影響到正式版的穩定性。 4.2 合併請求與程式碼審查 (Pull Request & Code Review) 當一個功能分支開發完成後，開發者會發起一個「合併請求」 (Pull Request, PR)，這是一個正式的「請求合併」的申請，也是我們團隊進行集體智慧品質把關的核心環節。 沒有經過審查的程式碼，就沒有資格被合併：這是我們的核心原則。PR 會通知團隊的其他成員進行程式碼審查 (Code Review)。 審查重點：審查者會關注邏輯正確性、程式碼品質、可維護性，並提出修改建議。 善用 AI 工具：我們也善用 AI 工具 (如 GitHub Copilot) 進行初步的 Code Review，它可以快速找出一些潛在問題，分擔人類審查者的部分工作。 透過這個流程，我們確保每一行合併進主分支的程式碼，都經過了至少一位「人類智慧」和一位「人工智慧」的雙重檢驗。 4.3 溝通與任務管理：交付可追溯的開發歷程 除了制定規則與導入工具，我們相信清晰、可追溯的溝通是專案成功的基石。 以 Pull Request 作為討論的載體：我們不僅利用 PR 進行程式碼審查，更將其作為一個公開的技術討論區。所有針對程式碼的建議、權衡與決策過程，都被完整地記錄下來，成為專案歷史的一部分。 以 Issues 進行系統化任務管理：我們使用 GitHub Issues 來管理專案的待辦事項，包括功能開發、Bug 修復與未來規劃。這讓團隊成員對專案的進程有共同的認知，也讓整個開發歷愈變得透明且有條理。 4.4 持續整合 (CI) - 自動化的品質守門員 在人工審查的基礎上，我們還有一位不知疲倦的「自動化守門員」。當 PR 被發起時，GitHub Actions 會自動執行兩道主要的品質檢測： 程式碼檢查 (flake8)：風格與品質檢查，捕捉潛在語法問題。 單元功能測試 (Pytest)：執行所有單元測試，確保新功能沒有破壞舊功能。 只有當人工審查和自動化測試都通過後，程式碼才被允許合併。 我們為專案的關鍵核心邏輯編寫了單元測試，主要涵蓋： 關鍵業務邏輯 (Business Logic)：驗證 Player 受創後的生命週期、Bomb 的狀態轉換、Item 的效果應用等核心遊戲規則。 資料持久化 (Data Persistence)：確保 LeaderboardManager 對於分數的讀寫與排序邏輯準確無誤。 邊界條件 (Edge Cases)：測試諸如生命值為零、炸彈數量達到上限等極端情況下的系統行為。 這些測試如同我們的「安全網」。在我們不斷新增功能或重構程式碼時，它能立刻捕捉到因修改而產生的意外錯誤 (Regression)，讓我們可以更有信心地進行開發迭代，確保了專案的長期穩定性。 4.5 持續部署 (CD) - 一鍵發佈到全世界 當程式碼成功合併到 分支後，持續部署流程會自動觸發。GitHub Actions 會自動將專案打包成網頁版本，並發佈到 GitHub Pages。這意味著每一次成功的合併，玩家就能在幾分鐘內玩到最新的遊戲版本，而我們完全不需要手動介入。 當程式碼成功合併到 分支後，部署流程會自動觸發。其流程如下圖所示： GitHub Actions 會自動將專案打包成網頁版本，並將遊戲發佈到網頁。 5. 技術挑戰與解決方案 所有成功的專案都不是一帆風順的，真正的學習往往發生在克服困難的過程中。在這裡，我們想分享幾個在開發 Pycade Bomber 時遇到的具體挑戰，以及我們是如何解決它們的。 5.1 AI 震盪之謎：狀態切換與遺失的路徑 在開發初期，我們遇到了AI 設計中一個非常經典的問題：行為震盪 (Oscillation)。 遇到的問題：AI 玩家在某些情況下會「卡住」，在原地微微顫抖，似乎在兩個目標或兩個狀態之間猶豫不決，無法執行任何有效的移動。 除錯過程：為了解決這個問題，我們為 AI 設計了一套詳細的日誌系統 ()，用來追蹤每一幀 (frame) AI 的狀態變化、決策過程以及路徑規劃的結果。透過分析大量的日誌，我們發現了一個奇怪的模式：AI 的路徑規劃函式確實成功計算並設定了一條有效的移動路徑，但幾乎在同一時間，當 AI 準備執行移動時，那條路徑卻又神秘地變成了空的。 根本原因：在追蹤程式碼後，我們終於找到了「兇手」——問題出在 類別的 函式中。我們最初的設計是，為了確保狀態切換的純粹性，每一次呼叫 時，都會無條件地將 AI 的當前移動路徑 () 清空。這導致了致命的連鎖反應：一個「規劃」狀態（如 ）辛辛苦苦計算出的路徑，在它呼叫 切換到「執行」狀態（如 ）的瞬間，就被 函式本身給清空了。AI 進入移動狀態後，發現無路可走，只好再次重新規劃，陷入了「規劃->清空->規劃」的死循環。 為了解決這個問題，我們重構了 函式。以下是修改前後的程式碼對比： 修改前 (有問題的版本) 修改後 (解決方案) 這個除錯過程讓我們深刻體會到，在複雜的狀態機設計中，狀態轉換時的「副作用管理」是多麼重要。一個看似無害的清理動作，如果沒有考慮到上下文，就可能導致難以追查的邏輯錯誤。 5.2 瀏覽器音訊的陷阱：解決 Web 環境的自動播放限制 將 Pygame 專案透過 部署到網頁上，雖然能讓玩家方便地體驗，但也帶來了許多 Web 環境獨有的挑戰，其中最典型的就是音訊播放問題。 遇到的問題：我們的遊戲在桌面版上音效一切正常，但部署到 Web 之後，一打開遊戲頁面，就會看到一個 的錯誤訊息，導致遊戲完全沒有聲音，尤其在手機瀏覽器上這個問題幾乎必然發生。 原因探究：經過研究我們了解到，這是現代瀏覽器為了提升使用者體驗而設下的「自動播放政策 (Autoplay Policy)」。為了防止惡意網站一打開就自動播放惱人的廣告或音樂，瀏覽器規定，任何音訊的播放（甚至包括音訊系統的初始化 )，都必須在使用者對頁面進行了首次「互動」（例如點擊、觸控）之後才能執行。我們原本的程式在遊戲一載入時就初始化了音訊系統，因此直接觸發了這個限制。 解決方案：我們的策略是「延遲初始化」。我們不再於遊戲啟動時立刻載入主遊戲場景，而是設計了一個全新的 (開始畫面) 作為遊戲的入口，並在 中實作了一個簡單的場景管理迴圈。 建立入口場景：遊戲從 開始，它的唯一任務，就是顯示一個簡單的「點擊畫面以開始遊戲」的提示。 等待使用者互動：程式會停在這個畫面，直到偵測到使用者的第一次滑鼠點擊或螢幕觸控。 互動後才初始化：在接收到使用者的互動事件後， 會結束，並回傳下一個場景（）的實例。在此之後，核心的 才能被安全地使用。 以下是 中主遊戲迴圈的簡化版，清晰地展示了這個流程： 這個「先互動，後載入」的流程，完美地繞過了瀏覽器的自動播放限制，確保了音訊系統能被合法啟動。這個經驗讓我們學到，將應用程式從一個平台移植到另一個平台時，必須充分考慮目標平台的獨特規範與限制，而不僅僅是程式碼本身的邏輯。這是一個典型的「在我的電腦上可以跑」(It works on my machine) 問題的 Web 版本，而解決它的過程讓我們獲益良多。 5.3 隨機地圖的生成與可玩性挑戰 為了大幅提升遊戲的重玩價值，我們決定加入隨機生成地圖的功能。然而，一個純粹隨機的結果很可能產生一個「死局」——例如，玩家一出生就被無法破壞的牆壁完全圍困。 遇到的挑戰：如何設計一個演算法，既能保證地圖的隨機性，又能 100% 確保從玩家 A 的出生點到玩家 B 的出生點之間，永遠存在一條可通行的路徑？ 解決方案：分層生成與連通性驗證：我們的策略分為兩步： 骨架生成與驗證：首先，我們在一個空白的地圖上，隨機灑上不可破壞的牆壁 (Solid Walls)。接著，立刻使用「廣度優先搜尋 (BFS)」演算法，檢查兩位玩家的出生點之間是否依然連通。如果此時路徑已經被阻斷，則放棄這次生成結果，重新嘗試，直到找到一個連通的「骨架」為止。 細節填充：在確保了地圖骨架連通性的基礎上，我們才在剩下的空白路徑上，隨機灑上可以被炸彈摧毀的牆壁 (Destructible Walls)。 穩健性設計：為了防止在極端情況下，演算法因無法生成連通地圖而陷入無限迴圈，我們還加入了一個「重試次數上限」機制。如果嘗試 50 次後依然失敗，系統會自動回退，載入一個保證可玩的經典地圖。 這個「先驗證、後填充」的流程，完美地平衡了隨機性與遊戲性的需求，確保玩家每一次選擇「隨機地圖」時，都能獲得一個充滿未知但絕對公平的戰場。 6. 總結與未來展望 從一個 C++ 的文字遊戲，到一個功能完整、部署在網頁上的 Pycade Bomber，這趟重構之旅讓我們收穫頗豐。這不僅僅是一次技術的升級，更是一次開發思維的全面進化。 我們成功地： 打造了穩健的軟體架構：透過物件導向與設計模式，讓專案的擴充與維護變得輕鬆。 實現了多策略的智慧 AI：結合 FSM 與路徑規劃，創造出懂得思考、行為多樣的遊戲對手。 建立了專業的開發流程：導入 CI/CD 自動化管線，從此告別手動測試與部署的繁瑣，向業界標準看齊。 這個專案最終不僅僅是一個可以玩的遊戲，更是我們團隊在軟體工程領域上，從設計、開發、測試到交付的完整實踐。 未來展望 (Future Work) Pycade Bomber 的世界還有廣闊的探索空間，我們規劃了幾個令人興奮的未來方向： 在【遊戲性】方面 ： 網路連線對戰：實現真正的多人線上對戰，這是 Bomberman 類型遊戲的靈魂！ 更多元的遊戲內容：設計更多樣化的地圖、特色道具與陷阱，甚至加入強大的 Boss 關卡。 關卡編輯器：讓玩家可以自行設計地圖，上傳並分享，實現使用者生成內容 (UGC)。 在【技術深度】方面 ： 強化學習 (Reinforcement Learning)：在現有的 AI 基礎上，引入強化學習模型進行訓練，讓 AI 能自主學習出更頂尖的遊戲策略。 效能與視覺優化：優化渲染效能，並加入更精美的粒子特效與角色動畫，提升整體的視覺體驗。 跨平台支援：將遊戲打包成桌面應用程式 (Windows/macOS)，而不僅限於網頁。 歡迎您的貢獻！(We Welcome Contributions!) Pycade Bomber 是一個充滿熱情的專案，我們也非常歡迎有同樣熱情的您加入社群，一同讓它變得更好！ 如果您發現了任何 Bug 或有新的功能想法，歡迎到我們的 GitHub Issues 頁面提出。 如果您希望直接貢獻程式碼，請先閱讀我們的貢獻指南 (CONTRIBUTING.md)，並隨時發起 Pull Request。 我們也標示了一些適合新手入門的 Good First Issues，如果您想小試身手，從這裡開始是個不錯的選擇！ 感謝您的閱讀！希望這篇文章能為正在學習 Python 遊戲開發或對軟體工程實踐感興趣的您帶來一些啟發。 如果您還沒玩過，不妨點擊下方連結，挑戰一下我們精心設計的 AI 吧！ 👉 馬上試玩： Pycade Bomber 線上遊戲連結 👉 查看原始碼： GitHub 專案連結","codeText":"Python Pygame Object-Oriented Programming (OOP) Finite State Machine (FSM) A* Search Git GitHub Actions (CI/CD) Pytest flake8 core/ menu.py ai_*.py audio_manager.py sprites/ player.py bomb.py wall.py assets/ test/ settings.py AudioManager game.py pygame.mixer # 在 game.py 中，呼叫就是這麼簡單\nself.audio_manager.play_sound('explosion')\n AudioManager # core/audio_manager.py\nimport pygame\n\nclass AudioManager:\n    def __init__(self):\n        pygame.mixer.init()\n        # 預先載入少量、常用的音效\n        self.sounds = {\n            'explosion': pygame.mixer.Sound('assets/audio/explosion.wav'),\n            'place_bomb': pygame.mixer.Sound('assets/audio/place_bomb.wav')\n        }\n\n    def play_sound(self, name):\n        if name in self.sounds:\n            self.sounds[name].play()\n Player Wall Item GameObject image rect AIControllerBase AggressiveAIController ConservativeAIController ESC Game PauseScene is_paused PauseScene Game PauseScene self PauseScene Game resume_game() is_paused if-else EVADING_DANGER TACTICAL_RETREAT_AND_WAIT PLANNING_ITEM_TARGET ENGAGING_PLAYER ENDGAME_HUNT collections.deque visited main main feature/new-item fix/bomb-bug main Python main main ai_log AIControllerBase change_state change_state self.current_movement_sub_path PLANNING_ITEM_TARGET change_state MOVING_TO_COLLECT_ITEM change_state change_state # ai_controller_base.py\n# 在 change_state 函式中，無條件清空路徑\ndef change_state(self, new_state):\n    if self.current_state != new_state:\n        # ... (更新狀態與時間)\n        self.current_state = new_state\n        self.state_start_time = pygame.time.get_ticks()\n\n        # 問題點：不論新狀態是什麼，都直接清空路徑！\n        self.current_movement_sub_path = [] \n        self.current_movement_sub_path_index = 0\n        # ...\n # ai_controller_base.py\n# 修改後的 change_state 函式\ndef change_state(self, new_state):\n    if self.current_state != new_state:\n        # ... (更新狀態與時間)\n        self.current_state = new_state\n        self.state_start_time = pygame.time.get_ticks()\n\n        # --- 解決方案 ---\n        # 只有在進入需要「重新規劃」的特定狀態時，才清空路徑。\n        # 這能避免剛設定好的路徑，在切換到「執行」狀態時被意外清除。\n        if new_state.startswith(\"PLANNING_\") or new_state in [\"IDLE\", \"DEAD\"]:\n            self.current_movement_sub_path = []\n            self.current_movement_sub_path_index = 0\n        \n        # ... (其他狀態清理邏輯) ...\n pygbag MEDIA USER ACTION REQUIRED pygame.mixer.init() StartScene main.py StartScene StartScene Menu AudioManager main.py # main.py\n\nasync def main():\n\t# ... (省略了 pygame 初始化與螢幕設定) ...\n\n\t# 建立唯一的 AudioManager 實例\n\taudio_manager = AudioManager()\n\n\t# 遊戲從 StartScene 開始，此時尚未播放音訊\n\tcurrent_scene = StartScene(screen, audio_manager, clock)\n\n\trunning_main_loop = True\n\twhile running_main_loop:\n\t\tevents = pygame.event.get()\n\t\t# ... (處理 QUIT 事件) ...\n\n\t\t# current_scene.update() 會處理該場景的邏輯，\n\t\t# 並在需要切換時，回傳下一個場景的實例\n\t\tnext_scene_candidate = current_scene.update(events, dt)\n\n\t\t# 如果回傳的不是當前場景，就進行切換\n\t\tif next_scene_candidate is not current_scene:\n\t\t\tcurrent_scene = next_scene_candidate\n\n\t\t# ... (處理繪圖與迴圈結束邏輯) ...\n\n\tpygame.quit()\n\nif __name__ == '__main__':\n\tasyncio.run(main())\n","mathText":"f(n) = g(n) + h(n) f(n) g(n) h(n)","category":"遊戲開發","tags":"Python AI Pygame","url":"/pycade-bomber-ai-and-cicd","slug":"pycade-bomber-ai-and-cicd"},{"id":3,"title":"[題解]TIOJ 1211 最小生成樹","date":"2025-05-10T00:00:00.000Z","plainText":"題目連結NEOJ 題目連結TIOJ 實作講義 資芽講義 這一題手刻最小生成樹，感覺蠻好的，都是利用一些性質來實作最小生成樹 最小生成樹的性質 性質一：樹 最小生成圖一定會是一棵樹，不具備環，且一共有n-1條邊 如果這張圖不是樹，則必定有環，即代表可以再拔掉一條邊使權重和更小 性質二：Cycle Property C是圖上的一個環，e是C上權重最大一條邊，則e必不在MST一部分（證明：反證，假設e在MST，則加入另一邊比e權重更小形成環，此時把e拔掉可以形成更小的權重和，因此矛盾） 性質三：Cut Property 把圖上的點集分割成兩半，則cut上面的邊集合中最小權重的邊e會在MST裡面（證明：反證，假設e不在MST，則加入e會形成連接兩半節點的環，此時拔掉另一比e權重大的邊，會形成更小權重和，因此矛盾） 利用性質二、性質三，就可以利用Kruskal演算法：利用到併查集的維護搭配路徑壓縮，可以快速判斷一個元素是否與另一個元素同屬一個集合（複雜度幾乎可以，更準確來說是），Kruskal總複雜度為 另外還有一種實作方式Prim's algorithm，等等再看 實作步驟 1. 初始化設定： 設定好boss以及集合大小等參數 2. 對所有的邊依照權重排序： 利用的時間排序，將邊依照權重由小到大加入MST中 3. 依序加入邊： 以下會有兩種情況，可以用並查集+路徑壓縮（優化）判斷是否會形成環 Case 1: 如果加了這條邊形成環（查到有一樣的boss） 那這條邊會是這個環上的最大邊 根據 Cycle property，這條邊不會是MST的一部分 Case 2: 加了這條邊不會形成環 那這條邊是條橋，連接左右兩棵樹 根據 Cut Property，因為這條邊是這個 cut 上最小的邊 所以這條邊會是 MST 的一部分 4. 判斷是否合法： n個點所形成的樹會有n-1條邊，最小生成樹是一棵樹就必須滿足條件。 KRUSKAL'S Algorithm Prim's Algorithm 是一種貪婪演算法，首先取任一點加入最小生成樹中，接著將連到的邊加入heap中，每一次取出heap中邊權重最小的邊，如果這一條邊連到的點尚未被走訪，則加入這一條邊為最小生成數。正確性證明則可用cut proprity證明每次都加入權重最小的邊即為最小生成數。","codeText":"#include <bits/stdc++.h>\n#define int long long\n#define N 200005\n#define ios ios::sync_with_stdio(0),cin.tie(0)\nusing namespace std;\nint n,m,num[N],boss[N];\nstruct Node{\n    int x,y,w;\n}edge[N];\n\nbool cmp(Node a, Node b){\n    return a.w < b.w;\n}\nint findboss(int a){                    //尋找集合的老大（代表整個集合）\n    if(a==boss[a])return a;\n    return boss[a]=findboss(boss[a]);   //遞迴搭配路徑壓縮\n}\n\nsigned main(){\n    ios;\n    cin>>n>>m;\n    for(int i=0;i<m;i++){\n        cin>>edge[i].x>>edge[i].y>>edge[i].w;\n    }\n    for(int i=0;i<n;i++){\n        num[i] = 1;\n        boss[i] = i;\n    }\n    sort(edge,edge+m,cmp);                 //依照權重大小放入MST\n    int result = 0,num_edge = 0;\n    for(int i=0;i<m && num_edge<n;i++){    //樹必須滿足小於n-1條邊\n        int a = findboss(edge[i].x),b = findboss(edge[i].y);\n        if(a!=b){                          //boss不同可以放入MST（加入不會形成環by Cut Property）\n            if(num[a]>=num[b]){            //執行啟發式合併\n                boss[b] = a;\n                num[a]+=num[b];\n            }\n            else{\n                boss[a] = b;\n                num[b]+=num[a];\n            }\n            result+=edge[i].w;\n            num_edge++;\n        }\n    }\n    cout<<result<<endl;\n    //這邊可以判斷num_edge==n-1有沒有成立，不過題目是輸入都可以形成MST\n}\n #include <bits/stdc++.h>\n#define Orz ios::sync_with_stdio(0),cin.tie(0)\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define pii pair<int,int>\n#define pdd pair<double,double>\n#define int long long\n#define ll long long\n#define ld long double\n#define N 200005\n#define eps 1e-9\n#define x first\n#define y second\nusing namespace std;\nint n,m;\nbool visit[N];\n\nstruct node{\n    int to,w;\n};\nvector<node> edge[N];\n\nstruct cmp{\n    bool operator()(node a,node b){\n        return a.w > b.w;\n    }\n};\n\nsigned main(){\n    Orz;\n    memset(visit,0,sizeof(visit));\n    cin>>n>>m;\n    rep(i,0,m-1){\n        int a,b,w;cin>>a>>b>>w;\n        edge[a].push_back({b,w});\n        edge[b].push_back({a,w});\n    }\n    priority_queue<node,vector<node>,cmp> pq;\n    visit[1] = 1;\n    for(auto i : edge[1])pq.push(i);\n    int num_edge = 0,ans = 0;\n    while(num_edge < n-1){\n        node x = pq.top();pq.pop();\n        if(visit[x.to])continue;\n        visit[x.to] = 1;\n        num_edge += 1;\n        ans += x.w;\n        for(auto i : edge[x.to]){\n            pq.push(i);\n        }\n    }\n    cout<<ans<<endl;\n}\n","mathText":"O(1) O(\\alpha) O(ElogE) O(m\\log m)","category":"資芽題解","tags":"資訊之芽 題解","url":"/sprout10-1","slug":"sprout10-1"},{"id":4,"title":"資芽第十週：進階圖論（一）","date":"2021-05-15T00:00:00.000Z","plainText":"上課內容 並查集 Disjoint Set 目標：快速判斷兩個元素是否同屬一個集合 功能：詢問元素隸屬的集合、合併兩個集合，在圖論中，集合通常表示連通快，並查集可以查詢任兩點是否連通。在實作MST的時候，當我們要檢查兩個點連接成的邊是否會跟其他已經加入的邊形成環，就會使用並查集幫助我們判斷！ 複雜度：非常優秀，可以說是O(1) 路徑壓縮 在回傳過程中順便利用遞迴把所經過的boss指向最上面的boss，由左圖變成右圖，效率更高（實測其實差不多，可能logn已經夠小加上遞迴本來就比較慢） 用遞迴實現的特性實現，遞迴拉上來的時候順便更新bossx]： 路徑壓縮搭配啟發式合併，複雜度：等同常數 上機作業 最小生成樹 [題目連結NEOJ 題目連結TIOJ 實作講義 資芽講義 這一題手刻最小生成樹，感覺蠻好的，都是利用一些性質來實作最小生成樹 性質一：樹 最小生成圖一定會是一棵樹，不具備環，且一共有n-1條邊 如果這張圖不是樹，則必定有環，即代表可以再拔掉一條邊使權重和更小 性質二：Cycle Property C是圖上的一個環，e是C上權重最大一條邊，則e必不在MST一部分（證明：反證，假設e在MST，則加入另一邊比e權重更小形成環，此時把e拔掉可以形成更小的權重和，因此矛盾） 性質三：Cut Property 把圖上的點集分割成兩半，則cut上面的邊集合中最小權重的邊e會在MST裡面（證明：反證，假設e不在MST，則加入e會形成連接兩半節點的環，此時拔掉另一比e權重大的邊，會形成更小權重和，因此矛盾） 利用性質二、性質三，就可以利用Kruskal演算法：利用到併查集的維護搭配路徑壓縮，可以快速判斷一個元素是否與另一個元素同屬一個集合（複雜度幾乎可以，更準確來說是），Kruskal總複雜度為 另外還有一種實作方式Prim's algorithm，等等再看 實作步驟 1. 初始化設定： 設定好boss以及集合大小等參數 2. 對所有的邊依照權重排序： 利用的時間排序，將邊依照權重由小到大加入MST中 3. 依序加入邊： 以下會有兩種情況，可以用並查集+路徑壓縮（優化）判斷是否會形成環 Case 1: 如果加了這條邊形成環（查到有一樣的boss） 那這條邊會是這個環上的最大邊 根據 Cycle property，這條邊不會是MST的一部分 Case 2: 加了這條邊不會形成環 那這條邊是條橋，連接左右兩棵樹 根據 Cut Property，因為這條邊是這個 cut 上最小的邊 所以這條邊會是 MST 的一部分 4. 判斷是否合法： n個點所形成的樹會有n-1條邊，最小生成樹是一棵樹就必須滿足條件。 KRUSKAL'S ALGORITHM Prim's Algorithm 是一種貪婪演算法，首先取任一點加入最小生成樹中，接著將連到的邊加入heap中，每一次取出heap中邊權重最小的邊，如果這一條邊連到的點尚未被走訪，則加入這一條邊為最小生成數。正確性證明則可用cut proprity證明每次都加入權重最小的邊即為最小生成數。 高棕櫚的意外收穫 題目連結 講義連結 這一題就是按照字典序print出尤拉路徑，特別用鄰接矩陣來存圖是因為要按照字典序輸出，如果用鏈結串列來存還要花時間排序，因此用大一點的空間來節省時間 尤拉路徑也是一筆畫問題，每一個節點一定會有進有出，因此原先的無向圖上每一點一定度數為偶數，若有奇點則選擇其中一個奇點作為起點，當奇點數量超過兩個則代表無解。我們將DFS的過程中離開當前節點的順序紀錄起來，逆序輸出就是一組合法歐拉迴路的解了！ 實作程序 1. 判斷奇點個數，若奇點個數k： k > 2，那麼無解 k = 2，則選擇其中一個奇點作為起點 k = 0，則選擇任意一個點作為起點 2. DFS 執行下列步驟 若當前節點還有尚未走過的邊，那麼拜訪該邊，並在拜訪完後輸出該邊 否則離開當前結點 3. 若還有節點尚未拜訪，則無解 4. 否則輸出順序即為一組解 陣線推進 題目連結 拓墣排序題，兩種實作方式，第一是BFS變形實作（queue實作），被pop出來的順序就是topological sort 第二種就是DFS搭配時間戳記，最晚離開的放在最前面 這一題是把入度為0的節點先push進priority_queue（按照字典序），當一個點處理過之後，入度變成0的所有它指向的點在push進queue裡面 拓墣排序可以用在DAG的判定以及解決具有依賴關係的問題 手寫作業 這一次的手寫也蠻困難的，討論BIT(fenwick tree)的實作以及複雜度！","codeText":"#include <bits/stdc++.h>\n#define N 100001\nusing namespace std;\nint n,boss[N],num[N];\n\nint find_boss(int a){        //使用路徑壓縮\n    if(a==boss[a])return a;\n    else return boss[a] = find_boss(boss[a]);\n}\n\nvoid merge(int a,int b){    //啟發式合併\n    if(num[a]>=num[b]){     //較小的集合合併到較大的集合\n        num[a] += num[b];\n        boss[b] = a;\n    }\n    else{\n        num[b] += num[a];\n        boss[a] = b;\n    }\n}\nsigned main(){\n    cin>>n;\n    for(int i=1;i<=n;i++){\n        boss[i] = i;\n        num[i] = 1;\n    }\n    while(1){\n        int a,b;cin>>a>>b;                    //要查詢兩個元素\n        a = find_boss(a),b = find_boss(b);    //判斷是否同屬一個集合\n        if(a!=b){                             //老大不同屬不同集合\n            cout<<\"不同集合\"<<endl;\n            merge(a, b);\n        }\n        else cout<<\"同集合\"<<endl;\n        for(int i=1;i<=n;i++)cout<<boss[i]<<\" \";\n        cout<<endl;\n    }\n}\n #include <bits/stdc++.h>\n#define int long long\n#define N 200005\n#define ios ios::sync_with_stdio(0),cin.tie(0)\nusing namespace std;\nint n,m,num[N],boss[N];\nstruct Node{\n    int x,y,w;\n}edge[N];\n\nbool cmp(Node a, Node b){\n    return a.w < b.w;\n}\nint findboss(int a){                    //尋找集合的老大（代表整個集合）\n    if(a==boss[a])return a;\n    return boss[a]=findboss(boss[a]);   //遞迴搭配路徑壓縮\n}\n\nsigned main(){\n    ios;\n    cin>>n>>m;\n    for(int i=0;i<m;i++){\n        cin>>edge[i].x>>edge[i].y>>edge[i].w;\n    }\n    for(int i=0;i<n;i++){\n        num[i] = 1;\n        boss[i] = i;\n    }\n    sort(edge,edge+m,cmp);                 //依照權重大小放入MST\n    int result = 0,num_edge = 0;\n    for(int i=0;i<m && num_edge<n;i++){    //樹必須滿足小於n-1條邊\n        int a = findboss(edge[i].x),b = findboss(edge[i].y);\n        if(a!=b){                          //boss不同可以放入MST（加入不會形成環by Cut Property）\n            if(num[a]>=num[b]){            //執行啟發式合併\n                boss[b] = a;\n                num[a]+=num[b];\n            }\n            else{\n                boss[a] = b;\n                num[b]+=num[a];\n            }\n            result+=edge[i].w;\n            num_edge++;\n        }\n    }\n    cout<<result<<endl;\n    //這邊可以判斷num_edge==n-1有沒有成立，不過題目是輸入都可以形成MST\n}\n #include <bits/stdc++.h>\n#define Orz ios::sync_with_stdio(0),cin.tie(0)\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define pii pair<int,int>\n#define pdd pair<double,double>\n#define int long long\n#define ll long long\n#define ld long double\n#define N 200005\n#define eps 1e-9\n#define x first\n#define y second\nusing namespace std;\nint n,m;\nbool visit[N];\n\nstruct node{\n    int to,w;\n};\nvector<node> edge[N];\n\nstruct cmp{\n    bool operator()(node a,node b){\n        return a.w > b.w;\n    }\n};\n\nsigned main(){\n    Orz;\n    memset(visit,0,sizeof(visit));\n    cin>>n>>m;\n    rep(i,0,m-1){\n        int a,b,w;cin>>a>>b>>w;\n        edge[a].push_back({b,w});\n        edge[b].push_back({a,w});\n    }\n    priority_queue<node,vector<node>,cmp> pq;\n    visit[1] = 1;\n    for(auto i : edge[1])pq.push(i);\n    int num_edge = 0,ans = 0;\n    while(num_edge < n-1){\n        node x = pq.top();pq.pop();\n        if(visit[x.to])continue;\n        visit[x.to] = 1;\n        num_edge += 1;\n        ans += x.w;\n        for(auto i : edge[x.to]){\n            pq.push(i);\n        }\n    }\n    cout<<ans<<endl;\n}\n #include <bits/stdc++.h>\n#define N 501\nusing namespace std;\nint n,Edge[N][N],ans[1025],ind = 0;\n\nvoid DFS(int cur){\n    for(int i=1;i<=500;i++){\n        if(Edge[cur][i]){\n            Edge[cur][i]--;Edge[i][cur]--;\n            DFS(i);\n        }\n    }\n    ans[ind++] = cur;\n}\n\nsigned main(){\n    cin>>n;\n    memset(Edge, 0, sizeof(Edge));\n    for(int i=0;i<n;i++){\n        int a,b;cin>>a>>b;\n        Edge[a][b]++;\n        Edge[b][a]++;\n    }\n    int start = 1;                //開始的節點編號\n    for(int i=1;i<=500;i++){\n        int sum = 0;\n        for(int j=1;j<=500;j++){\n            sum+=Edge[i][j];\n        }\n        if(sum%2!=0){             //找到第一個度數為奇數的節點\n            start = i;\n            break;\n        }\n    }\n    DFS(start);\n    for(int i=ind-1;i>=0;i--)cout<<ans[i]<<endl;\n}\n #include <bits/stdc++.h>\n#define N 100001\nusing namespace std;\nint t,n,m,deg[N];//入度\nint ans[N],ind = 0;\n\nsigned main(){\n    cin>>t;\n    while(t--){\n        memset(deg,0,sizeof(deg));\n        memset(ans, 0, sizeof(ans));\n        ind = 0;\n        vector<int> edge[N];\n        cin>>n>>m;\n        for(int i=0;i<m;i++){\n            int a,b;cin>>a>>b;\n            edge[a].push_back(b);\n            deg[b]++;\n        }\n        priority_queue<int,vector<int>,greater<int> > qq;//priority_queue取代queue\n        for(int i=0;i<n;i++)if(deg[i]==0)qq.push(i);\n        while(!qq.empty()){\n            int cur = qq.top();\n            qq.pop();\n            ans[ind++] = cur;\n            int len = edge[cur].size();\n            for(int i=0;i<len;i++){\n                deg[edge[cur][i]]--;\n                if(deg[edge[cur][i]]==0)\n                    qq.push(edge[cur][i]);\n            }\n        }\n        if(ind==n){\n            cout<<ans[0];\n            for(int i=1;i<n;i++)cout<<\" \"<<ans[i];\n            cout<<endl;\n        }\n        else cout<<\"QAQ\"<<endl;\n    }\n}\n","mathText":"O(α(N)) O(1) O(\\alpha) O(ElogE) O(m\\log m)","category":"資訊之芽筆記","tags":"資芽筆記 圖論","url":"/sprout10","slug":"sprout10"},{"id":5,"title":"[題解]NEOJ 739 芽芽逛大街","date":"2021-01-10T00:00:00.000Z","plainText":"芽芽逛大街 題目連結 有向無環圖的 case → DAG 最長路徑! 將每個強連通元件縮成點後，因為內部的點可以一直亂走全部走到，所以只要將新點的點權更新成內部所有點的點權總和，得到一張新的有向無環圖，就可以直接做 DAG 最長路徑得到答案。","codeText":"#include <bits/stdc++.h>\n#define int long long\n#define ios ios::sync_with_stdio(0),cin.tie(0);\n#define N 500002\nusing namespace std;\nint n,m,dfn[N],low[N],es = 1,stk_in[N],vertex_val[N],deg[N];\n//dfn為時間戳記,low為back, cross edge（經過最多一次）到達最小點dfn,stk_in是否在stack內\nbool visit[N];\nint scc[N],scc_ind = 0,scc_val[N];//紀錄屬於哪個scc,scc編號,scc編號的價值（權重和）\nint topological_order[N],ind = 0;\n\nstruct edg{\n    int to;\n    int val;\n};\n\nvector<edg> edge[N],new_edge[N];\nstack<int> s;\n\nvoid DFS(int now){\n    dfn[now] = low[now] = es++;\n    s.push(now);\n    stk_in[now] = 1;\n    visit[now] = 1;\n    int len = edge[now].size();\n    for(int i=0;i<len;i++){\n        int next = edge[now][i].to;\n        if(!visit[next]){       //尚未拜訪則拜訪\n            DFS(next);\n            low[now] = min(low[now],low[next]);\n        }\n        else if(stk_in[next]){  //在stk內且已拜訪->同屬一個SCC\n            low[now] = min(low[now],dfn[next]);\n            //這條邊指向還沒出stack的點，可為cross or back edge 更新low[now]\n        }\n    }\n    //如果是scc就pop stack裡面的東西\n    if(low[now] == dfn[now]){\n        stk_in[now] = 0;        //pop出stack裡面\n        scc[now] = ++scc_ind;   //進行SCC編號\n        scc_val[scc_ind] = vertex_val[now]; //更新點權\n        while(s.top()!=now){                //pop直到now被找到\n            scc[s.top()] = scc_ind;\n            stk_in[s.top()] = 0;            //pop出來\n            scc_val[scc_ind] += vertex_val[s.top()];\n            s.pop();\n        }\n        s.pop();//將stack 中now也pop\n    }\n}\n\nsigned main(){\n    ios;\n    cin>>n>>m;\n    memset(visit, 0, sizeof(visit));\n    memset(stk_in, 0, sizeof(stk_in));\n    memset(deg, 0, sizeof(deg));\n    for(int i=1;i<=n;i++){\n        int x;cin>>x;\n        vertex_val[i] = x;\n    }\n    for(int i=0;i<m;i++){\n        int x,y,val;cin>>x>>y>>val;//x指向y\n        edge[x].push_back( edg{y,val} );\n    }\n    for(int i=1;i<=n;i++)\n        if(!visit[i])DFS(i);\n    \n    //枚舉每一條邊更新邊權\n    for(int i=1;i<=n;i++){\n        int len = edge[i].size();\n        for(int j=0;j<len;j++){\n            int to = edge[i][j].to;\n            if(scc[to]==scc[i]){\n                int ind = scc[to];\n                scc_val[ind]+=edge[i][j].val;\n            }\n            else{   //不同SCC指向不同的邊\n                new_edge[scc[i]].push_back( edg{scc[to],edge[i][j].val});\n                deg[scc[to]]++;\n            }\n        }\n    }\n    \n    //Topological sort\n    queue<int> q;\n    \n    for(int i=1;i<=scc_ind;i++)\n        if(deg[i]==0)q.push(i);\n\n    while(!q.empty()){\n        int now = q.front(),len = new_edge[now].size();\n        topological_order[ind++] = now;\n        q.pop();\n        for(int i=0;i<len;i++){\n            int next = new_edge[now][i].to;\n            if(--deg[next]==0)q.push(next);\n        }\n    }\n    \n    //拓墣排序完進行DP找最長路徑\n    int dp[ind],ans = 0;\n    for(int i=1;i<=scc_ind;i++){\n        dp[i] = scc_val[i];\n        ans = max(ans, scc_val[i]);\n    }\n    \n    for(int i=0;i<ind;i++){\n        int now = topological_order[i],len = new_edge[now].size();\n        for(int j=0;j<len;j++){\n            int next = new_edge[now][j].to;\n            dp[next] = max(dp[next],scc_val[next]+dp[now]+new_edge[now][j].val);\n            ans = max(ans, dp[next]);\n        }\n    }\n    cout<<ans<<endl;\n}\n","mathText":"","category":"資芽題解","tags":"資芽筆記 題解","url":"/sprout11-4","slug":"sprout11-4"},{"id":6,"title":"資芽第十一週：進階圖論（二）","date":"2021-05-22T00:00:00.000Z","plainText":"上課內容 雙連通元件 樹壓平、點雙連通、邊雙連通 SCC強連通元件 LCA（最低共同祖先） 上機作業 高棕櫚傳遞鏈 題目連結 在一張圖中找割點（定義：拔掉它整張圖就不連通了） 作法：如果用暴力，可以每一個點拔掉，做一次DFS判斷是否聯通（效率太差） 效率更高的就是Trajan 演算法找AP(articulation point) Tarjan's algorithm 找 AP 邊的種類可以分成：Tree edge,Back edge,Forward edge,Cross edge，其中無向圖中只會有樹邊跟回邊（按照無向邊DFS的結果，Foward edge 都會變成子孫的back edge, cross edge 會變成樹邊） 維護一個low函數，代表不經過父節點能到的最小時間戳記（進入）的節點，lv函數為當前節點的時間戳記。一個點是不是割點，只要他的任意子節點的low函數大於等於自己的時間戳記編號，那把這個點拔掉，他小孩就走不到祖先了（如果走得到祖先，對於這一棵子樹，拔掉當前節點就可利用此邊繼續連通），所以他就是割點。 更新：分別為利用子孫或靠自己 必須要注意的是，割點判斷時要把root的特例獨立判斷。其實root反而比較簡單，如果root有超過一個子樹，代表拔掉root以後會分裂成以每個子樹為單位的連通塊 謠言問題 題目連結 跟上一題（高棕櫚傳遞鏈）蠻類似的，一樣找到割點，不同的是要在DFS過程中同時紀錄子樹節點的數量。如果碰到割點，維護拔掉它之後分裂出去那些子樹的節點個數，到時候透過節點總數-拔掉後分裂個數即可推算有幾個人會知道謠言，取min即可 高棕櫚傳遞鏈 題目連結 前兩題找割點，這一題是找橋，跟找割點的方法幾乎一樣，而且對於邊還不需要討論root的情況（root變成不是特例），然後判斷割點的 >= 變成 >，原因可以透過畫圖理解（把點拔掉跟把邊拔掉的差別），就可以實作了！ 題目有一個特別的要求，按照給邊的順序進行輸出，那可以搭配set來快速查看某一元素是否在集合內，接著就按照給定的條件來輸出 芽芽逛大街 題目連結 有向無環圖的 case → DAG 最長路徑! 將每個強連通元件縮成點後，因為內部的點可以一直亂走全部走到，所以只要將新點的點權更新成內部所有點的點權總和，得到一張新的有向無環圖，就可以直接做 DAG 最長路徑得到答案。 手寫作業 介紹雜湊，重點在於rolling hash，這也是下一週隨機課程當中會用到的重要概念。","codeText":"#include <bits/stdc++.h>\n#define ios ios::sync_with_stdio(0),cin.tie(0);\n#define int long long\n#define N 1000001\nusing namespace std;\nint n,m,low[N],lv[N],es=1,root,son_cnt = 0;\nbool visit[N],ans[N];\nvector<int> edge[N];\n//low函數為不經過父節點能到的最小時間戳記,lv為當前進入時間戳記\n\nvoid DFS(int now,int father){\n    visit[now] = 1;             //將此點設為已拜訪\n    low[now] = lv[now] = es++;  //進入的時間戳記\n    \n    int len = edge[now].size();\n    for(int i=0;i<len;i++){     //拜訪每一個子孫\n        int next = edge[now][i];\n        if(now==root && !visit[next])son_cnt++;//計算root小孩（處理特例）\n        if(!visit[next]){       //排除走到祖先的情況\n            DFS(next, now);\n            if(low[next]>=lv[now] && now!=root)ans[now]=1;\n            //無法透過小孩到達比自己淺的節點，將now設為AP\n        }\n        if(next!=father)low[now] = min(low[now],low[next]);\n        //排除指向父親的情況，如果經過父親，拔掉就不能往更上面去\n    }\n}\n\nsigned main(){\n    ios;\n    cin>>n>>m;\n    memset(lv, 0, sizeof(lv));\n    memset(low, 0, sizeof(low));\n    memset(visit, 0, sizeof(visit));\n    memset(ans,0,sizeof(ans));\n    \n    for(int i=0;i<m;i++){\n        int x,y;cin>>x>>y;\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n    for(int i=0;i<n;i++){\n        if(!visit[i]){\n            root = i;\n            son_cnt = 0;\n            DFS(i, i);\n            if(son_cnt>1)ans[root] = 1;\n        }\n    }\n    for(int i=0;i<n;i++)if(ans[i])cout<<i<<endl;\n}\n #include <bits/stdc++.h>\n#define ios ios::sync_with_stdio(0),cin.tie(0);\n#define int long long\n#define N 30001\nusing namespace std;\nint n,m,root,lv[N],low[N],tree_cnt[N],es = 1;\nbool visit[N],ans[N];\nvector<int> edge[N];\n\nint DFS(int now,int father){      //回傳當前子節點個數\n    visit[now] = 1;\n    lv[now] = es;\n    low[now] = es++;\n    \n    int len = edge[now].size(),sum=1;//計算節點數\n    for(int i=0;i<len;i++){\n        int next = edge[now][i];     //下一個節點\n        \n        if(!visit[next]){\n            int temp = DFS(next,now);\n            sum += temp;\n            if(low[next] >= lv[now] && now!=root){ //不能拔掉root\n                ans[now] = 1;           //設為AP\n                tree_cnt[now] += temp;  //被拔掉後可被分割成幾個連通塊節點數\n            }\n        }\n        if(next!=father)low[now] = min(low[now],low[next]);\n    }\n    return sum;\n}\n\nsigned main(){\n    ios;\n    cin>>n>>m;\n    for(int i=0;i<m;i++){\n        int x,y;cin>>x>>y;\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n    }\n    cin>>root;\n    \n    memset(ans, 0, sizeof(ans));\n    memset(visit, 0, sizeof(visit));\n    memset(tree_cnt, 0, sizeof(tree_cnt));\n    \n    int sum = DFS(root,root),min_cnt = INT_MAX,min_pos = 0;\n    \n    for(int i=1;i<=n;i++){\n        int temp = sum-tree_cnt[i]; //拔掉後剩下連通塊大小（跟root連的）\n        if(ans[i] && temp < min_cnt){\n            min_pos = i;        //拔掉第幾個\n            min_cnt = temp;     //更新拔掉後剩下連通塊大小\n        }\n    }\n    if(min_cnt == INT_MAX)cout<<0<<endl;\n    else cout<<min_pos<<\" \"<<min_cnt<<endl;\n}\n\n #include <bits/stdc++.h>\n#define ios ios::sync_with_stdio(0),cin.tie(0);\n#define int long long\n#define N 1000001\nusing namespace std;\nint n,m,lv[N],low[N],timestamp = 1;\nbool visit[N];\nvector<int> edge[N];\nvector<pair<int, int>> ans;\nset<pair<int, int>>s;\n\nvoid DFS(int now,int father){\n    lv[now] = low[now] = timestamp++;\n    visit[now] = 1;\n    \n    int len = edge[now].size();\n    for(int i=0;i<len;i++){\n        int next = edge[now][i];\n        \n        if(!visit[next]){\n            DFS(next, now);\n            if(low[next] > lv[now]){\n                if(next<now)s.insert(make_pair(next,now));\n                else s.insert(make_pair(now, next));\n            }\n        }\n        if(next!=father)low[now] = min(low[now],low[next]);\n    }\n}\n\nsigned main(){\n    ios;\n    cin>>n>>m;\n    for(int i=0;i<m;i++){\n        int x,y;cin>>x>>y;\n        edge[x].push_back(y);\n        edge[y].push_back(x);\n        ans.push_back(make_pair(x, y));\n    }\n    memset(visit, 0, sizeof(visit));\n    \n    for(int i=1;i<=n;i++){\n        if(!visit[i]){\n            DFS(i, i);\n        }\n    }\n    for(int i=0;i<m;i++){\n        pair<int, int> temp = ans[i];\n        if(s.find(temp)!=s.end()){\n            cout<<temp.first<<\" \"<<temp.second<<endl;\n        }\n    }\n}\n #include <bits/stdc++.h>\n#define int long long\n#define ios ios::sync_with_stdio(0),cin.tie(0);\n#define N 500002\nusing namespace std;\nint n,m,dfn[N],low[N],es = 1,stk_in[N],vertex_val[N],deg[N];\n//dfn為時間戳記,low為back, cross edge（經過最多一次）到達最小點dfn,stk_in是否在stack內\nbool visit[N];\nint scc[N],scc_ind = 0,scc_val[N];//紀錄屬於哪個scc,scc編號,scc編號的價值（權重和）\nint topological_order[N],ind = 0;\n\nstruct edg{\n    int to;\n    int val;\n};\n\nvector<edg> edge[N],new_edge[N];\nstack<int> s;\n\nvoid DFS(int now){\n    dfn[now] = low[now] = es++;\n    s.push(now);\n    stk_in[now] = 1;\n    visit[now] = 1;\n    int len = edge[now].size();\n    for(int i=0;i<len;i++){\n        int next = edge[now][i].to;\n        if(!visit[next]){       //尚未拜訪則拜訪\n            DFS(next);\n            low[now] = min(low[now],low[next]);\n        }\n        else if(stk_in[next]){  //在stk內且已拜訪->同屬一個SCC\n            low[now] = min(low[now],dfn[next]);\n            //這條邊指向還沒出stack的點，可為cross or back edge 更新low[now]\n        }\n    }\n    //如果是scc就pop stack裡面的東西\n    if(low[now] == dfn[now]){\n        stk_in[now] = 0;        //pop出stack裡面\n        scc[now] = ++scc_ind;   //進行SCC編號\n        scc_val[scc_ind] = vertex_val[now]; //更新點權\n        while(s.top()!=now){                //pop直到now被找到\n            scc[s.top()] = scc_ind;\n            stk_in[s.top()] = 0;            //pop出來\n            scc_val[scc_ind] += vertex_val[s.top()];\n            s.pop();\n        }\n        s.pop();//將stack 中now也pop\n    }\n}\n\nsigned main(){\n    ios;\n    cin>>n>>m;\n    memset(visit, 0, sizeof(visit));\n    memset(stk_in, 0, sizeof(stk_in));\n    memset(deg, 0, sizeof(deg));\n    for(int i=1;i<=n;i++){\n        int x;cin>>x;\n        vertex_val[i] = x;\n    }\n    for(int i=0;i<m;i++){\n        int x,y,val;cin>>x>>y>>val;//x指向y\n        edge[x].push_back( edg{y,val} );\n    }\n    for(int i=1;i<=n;i++)\n        if(!visit[i])DFS(i);\n    \n    //枚舉每一條邊更新邊權\n    for(int i=1;i<=n;i++){\n        int len = edge[i].size();\n        for(int j=0;j<len;j++){\n            int to = edge[i][j].to;\n            if(scc[to]==scc[i]){\n                int ind = scc[to];\n                scc_val[ind]+=edge[i][j].val;\n            }\n            else{   //不同SCC指向不同的邊\n                new_edge[scc[i]].push_back( edg{scc[to],edge[i][j].val});\n                deg[scc[to]]++;\n            }\n        }\n    }\n    \n    //Topological sort\n    queue<int> q;\n    \n    for(int i=1;i<=scc_ind;i++)\n        if(deg[i]==0)q.push(i);\n\n    while(!q.empty()){\n        int now = q.front(),len = new_edge[now].size();\n        topological_order[ind++] = now;\n        q.pop();\n        for(int i=0;i<len;i++){\n            int next = new_edge[now][i].to;\n            if(--deg[next]==0)q.push(next);\n        }\n    }\n    \n    //拓墣排序完進行DP找最長路徑\n    int dp[ind],ans = 0;\n    for(int i=1;i<=scc_ind;i++){\n        dp[i] = scc_val[i];\n        ans = max(ans, scc_val[i]);\n    }\n    \n    for(int i=0;i<ind;i++){\n        int now = topological_order[i],len = new_edge[now].size();\n        for(int j=0;j<len;j++){\n            int next = new_edge[now][j].to;\n            dp[next] = max(dp[next],scc_val[next]+dp[now]+new_edge[now][j].val);\n            ans = max(ans, dp[next]);\n        }\n    }\n    cout<<ans<<endl;\n}\n","mathText":"low[now] = min(low[now],low[next]) O(logN)","category":"資訊之芽筆記","tags":"資芽筆記 圖論","url":"/sprout11","slug":"sprout11"}]