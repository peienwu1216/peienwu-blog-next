# Peienwu's Code Lab - 新一代個人技術部落格

[![Vercel Deployment](https://img.shields.io/github/deployments/peienwu1216/peienwu-blog-next/production?label=Vercel&logo=vercel&style=for-the-badge)](https://peienwu-blog-next.vercel.app/)

歡迎來到我的新一代技術部落格！這是一個使用 Next.js (App Router)、Contentlayer 和 Tailwind CSS 從零開始打造的現代化、高效能、且專注於閱讀體驗的個人網站。這裡不僅是我記錄學習筆記、分享專案心得的地方，也是我實踐最新前端技術的實驗場。

**線上預覽：** [peienwu-blog-next.vercel.app/](https://peienwu-blog-next.vercel.app/)

![image (14)](https://github.com/user-attachments/assets/7f0dd5a1-2b18-4999-bad9-c96be52c92fd)

## 🌟 專案亮點總結 (Key Highlights)

這個專案不僅僅是一個部落格，它是一個**精心設計的全端應用程式**，旨在展示現代化的工程實踐與極致的使用者體驗。以下是其核心所在：

### 1. 🎵 遊戲化的共享音樂體驗 (Gamified Shared Music Experience)

* **全站共享派對模式**：基於 **Spotify Web Playback SDK** 從零到一打造，任何訪客都能加入由「派對DJ」控制的共享音樂佇列。這不僅是個播放器，更是一種新穎的、跨裝置的社交互動體驗。
* **智慧型閒置重置制**：我設計了一套精巧的**智慧主控權管理系統**。主控權會在DJ每一次有效操作後自動重置倒數計時，獎勵活躍使用者；同時在DJ閒置2分鐘後自動釋放控制權，確保資源的公平流動。
* **無縫會話恢復**：即使主控者不小心刷新了頁面，系統也能透過 `sessionId` 比對，**智慧地為其恢復DJ身份**，避免了因 Spotify SDK 重新分配 `deviceId` 而導致的控制權意外丟失問題。
* **情境感知的 UI/UX**：播放器會根據您的身份（主控DJ、鎖定中、可搶佔）動態渲染完全不同的介面。等待者不僅能看到倒數計時，更能看到是哪位「**隨機代號的DJ**」在控制，以及其「**操作次數**」和「**控場時長**」，將被動的等待轉化為有趣的觀戰。

### 2. 🧠 AI 驅動的數位分身與架構實踐 (AI-Powered Digital Twin & Architectural Practice)

*   **雙 AI 智慧助理架構**：設計了「文章專家」與「全站數位分身」的雙 AI 體系。前者提供針對性內容解析，後者則透過**長上下文注入 (Long-Context Injection)** 技術，整合我完整的知識體系，實現真正個人化的深度對話。
*   **從 RAG 到長上下文的技術演進**：在親自實作並評估基礎關鍵字 RAG 的局限性後，**策略性地選擇**了更適合本專案的長上下文注入方案，展現了從問題定義、實作驗證到架構優化的完整工程思維。
*   **自動化知識庫建置**：透過自訂 Node.js 腳本在**建置時 (Build Time)** 自動處理所有內容來源，將其轉化為結構化 AI 知識庫，確保了前端問答的高效能與低延遲。

### 3. 🚀 應用程式級的互動體驗 (Application-Grade Experience)
* **`⌘+K` 指揮中心**：實作了超越傳統搜尋的**巢狀指令面板**。它不僅能以毫秒級速度搜尋全站內容，更能**執行動作**（如切換主題）、**層級式導覽**，並**整合後端 API**。
* **動態儀表板**：專案頁面和指令面板能**即時**從 GitHub 拉取專案的星級、開發中任務等**動態數據**，並透過**智慧快取策略**兼顧即時性與效能，徹底擺脫靜態網站的限制。

### 4. 🧠 專業級搜尋引擎架構 (Professional Search Engine Architecture)
* **建置時索引 (Build-Time Indexing)**: 在 `next build` 階段，透過自訂腳本將所有文章預先處理成一個**輕量、乾淨的 JSON 搜尋索引**，實現了前端的極速查詢。
* **智慧型多重索引**：將內容拆分為「純文字」、「程式碼」、「數學公式」等多重索引，並為**不同欄位設定不同權重**（`標題 > 標籤 > 內文 > 程式碼`），讓搜尋結果極其精準且符合使用者預期。
* **上下文感知查詢**：搜尋邏輯能**自動偵測**使用者輸入的是「自然語言」還是「程式碼/數學符號」，並**動態調整**最小搜尋長度與匹配模式，實現了真正的「智慧搜尋」。

## 5. 🏗️ 現代化的全端工程實踐 (Modern Full-Stack Engineering)
* **API 路由與安全**：透過 Next.js API Routes 建立後端服務，安全地在伺服器端處理如 **GitHub PAT (Personal Access Token)** 等敏感金鑰，實現與 GitHub 私有專案的通訊。
* **效能優化策略**：針對不同 API（`開發計畫` vs. `專案統計`）的特性，分別採用 **60 秒**和 **1 小時**兩種不同的**伺服器端快取 (`revalidate`) 策略**，在效能、成本與即時性之間做出了精準的權衡。

> **總結來說，此專案完整地展示了我從前端互動設計、後端 API 開發、搜尋引擎架構，到 DevOps 自動化部署與效能優化的全端工程能力。**

## 🧠 AI 數位分身的架構演進 (Architectural Evolution of the AI Digital Twin)

此專案的另一大亮點，是打造了一個能深度理解我個人背景與所有文章知識的「AI 數位分身」。它的開發過程，是一次從追隨技術熱點到回歸問題本質的寶貴實踐。

#### 第一階段：RAG 的探索與實踐 (Exploration of RAG)

我最初採用了**檢索增強生成 (Retrieval-Augmented Generation, RAG)** 架構。我成功建立了一個系統，它能索引我全部（包括 286 篇舊文在內）的文章，並在使用者提問時，透過**關鍵字匹配**來檢索相關段落，再提供給 AI 生成答案。

-   **遭遇的挑戰：** 在實測中，我發現純粹基於關鍵字的檢索，無法真正理解提問的「語意」。這導致系統常提取到表面相關但實則文不對題的片段，使得 AI 的回答常常**不知所云**，無法達到預期的深度與準確度。我意識到，一個穩健的 RAG 系統，必須建立在更先進的**語意向量檢索 (Semantic Vector Search)** 之上，而這對於個人專案來說是一個龐大的工程。

#### 第二階段：策略性轉向「長上下文注入」(Strategic Pivot to Long-Context Injection)

鑑於此番洞察，並考量到 **Google Gemini** 等現代語言模型已具備強大的長上下文處理能力，我決定進行一次架構上的策略轉向。

-   **新架構：** 我開發了一套在**建置時期 (Build Time)** 運行的 Node.js 腳本。它會預先掃描我所有的知識來源——文章、專案履歷、個人背景——將其預處理、清洗並結構化成一個完整的 `JSON` 知識庫。在使用者提問時，此知識庫會被**完整地注入到 AI 的提示 (Prompt)** 中。

-   **成果與結論：** 這個「長上下文注入」的新架構，確保了 AI 能在我的**完整知識視野**下進行推理與回答，結果是回答的**連貫性、全面性與個人風格**都得到了質的飛躍。

> 這次從 RAG 到長上下文注入的演進，不僅是一次技術迭代，更讓我深刻體會到：**選擇最「適合」當前問題與資源的技術，遠比追求最「時髦」的技術名詞來得更重要。**

## 🎭 人格工程：從設定檔到真實對話 (Personality Engineering: From Config to Conversation)

一個真正的「數位分身」，不僅要有知識，更要有「個性」。為此，我設計了一套系統性的人格工程流程，將抽象的人格特質轉化為 AI 可理解並執行的具體指令。

#### 1. 核心思想：分層式人格設定檔 (`personality.mdx`)

我並非直接給予 AI 模糊的指令，而是建立了一個結構化的 `ai/personality.mdx` 設定檔。此檔案作為 AI 人格的**唯一真實來源 (Single Source of Truth)**，將人格拆分為不同層次：

-   **溝通風格 (Tone & Style):** 定義 AI 的外在表現，如「務實的創造者與熱情的分享家」。
-   **價值觀與哲學 (Values & Philosophy):** 構成 AI 思考與決策的核心信念，如對「教學相長」的看法，以及將 AI 視為「超級樂高積木」的比喻。
-   **抱負與動機 (Aspirations & Motivations):** 驅動 AI 前進的內在動力，包含對自我的期許與反思。
-   **背景故事 (Background Narrative):** 結構化的個人經歷與關鍵成就，讓 AI 能分享有溫度的故事，而不僅是冰冷的數據。

#### 2. 迭代方法：提問、分析、優化循環

有了設定檔後，我採用了一套「**提問 -> 分析 -> 優化**」的敏捷迭代循環，來不斷校準 AI 的行為：

1.  **設計提問 (Design Questions):** 針對人格設定檔的不同層次，設計出標準化和充滿挑戰的場景問題。
2.  **分析回答 (Analyze Responses):** 仔細比對 AI 的實際回答與設定檔中的預期表現，找出其中的差距。例如，我發現 AI 初期會將生動的故事「總結」成條列式的心得報告，失去了溫度。
3.  **迭代優化 (Iterate & Refine):** 針對發現的問題，回頭**重構 `personality.mdx` 的結構**。例如，我將大段的 `backgroundNarrative` 拆分成帶有 `title` 和 `story` 的結構化陣列，成功引導 AI 從「總結者」變成了「分享者」；我也將分散的 `on_ai` 觀點，合併成以「樂高」為核心的統一論述，使其回答更具創造性。

> 透過這個不斷打磨的過程，AI 的回答從最初的「資訊提取」逐漸演變為真正帶有個人風格、價值觀與情感溫度的「人格演繹」。這證明了打造一個成功的數位分身，精巧的「人格工程」與「技術架構」同等重要。

## 📁 專案結構

```
.
├── ai/
│   └── personality.mdx     # 🎭 AI 數位分身的核心人格設定檔
├── content/
│   └── posts/              # .mdx 格式的部落格文章
├── public/
│   └── search-data.json    # ✨ FlexSearch 的預建置搜尋索引
├── scripts/
│   └── build-search.mjs    # ✨ 用於在建置時產生 `search-data.json` 的腳本
├── src/
│   ├── app/                # Next.js App Router: 頁面、API 路由與全域樣式
│   │   ├── api/            # 🔗 全端 API 路由 (GitHub 整合)
│   │   └── ...
│   ├── components/         # 共用的 React 元件
│   │   └── CommandPalette.tsx # 🧠 Cmd+K 指揮中心的核心 UI
│   └── lib/                # 輔助函式與客戶端工具
│       └── flexsearch.ts     # 🧠 FlexSearch 引擎的客戶端邏輯
├── contentlayer.config.ts  # 🛠️ Contentlayer 設定檔 (定義內容模型)
├── next.config.js          # Next.js 設定檔
├── package.json            # 專案依賴與腳本 (新增 `flexsearch`, `concurrently`)
└── tailwind.config.js      # Tailwind CSS 設定檔
```
**圖示說明 (Legend):**
* 🎭 人格中樞: 定義 AI 數位分身的核心人格與背景知識。
* ✨ 核心亮點: 體現本專案「建置時索引」獨特架構的關鍵檔案。
* 🧠 智慧中樞: 驅動專業級搜尋與指令功能的核心邏輯。
* 🔗 全端橋樑: 連接前端與外部服務 (GitHub API) 的後端路由。
* 🛠️ 內容引擎: 定義內容如何被處理、驗證與轉換。

## ✨ 核心功能 (Features)

本專案不僅是一個部落格，更是一個從架構、體驗到內容管線都經過精心設計的全端應用。

### 🎵 技術深度剖析：Spotify 共享音樂體驗的設計與實現

為了將單純的音樂播放功能，提升為一個穩定、安全且充滿互動樂趣的「共享派對體驗」，我在後端架構、狀態管理與前端 UI 上進行了大量的精心設計。受限於 Spotify 只限單一裝置的共享音樂政策限制，我設計了「爭奪 DJ 控制台」的機制，讓搶奪音樂主控權成為一個競爭遊戲，提升趣味，未取得控制權的訪客，也可一同共享音樂配對體驗，並等待一段時間後搶奪電台主控權。

#### 1. 非同步競爭下的狀態一致性設計

**挑戰**：在一個開放的網路環境中，多位訪客可能在**毫秒級的時間差**內同時點擊「成為派對DJ」按鈕。這會引發**競爭條件 (Race Condition)**，如果處理不當，會導致狀態錯亂（例如多位DJ同時存在）或系統崩潰。

**我的解決方案**：
*   **後端原子化操作**: 我將「搶佔控制權」的核心邏輯設計為一個**後端原子操作**。透過在伺服器端（Redis）使用 `SETNX` (SET if Not Exists) 這類原子指令，我確保了在任何時刻，只有**第一個到達的請求**能夠成功設定「主控裝置 ID」，後續所有請求都會在該次操作中失敗。這從根本上杜絕了競爭條件。
*   **即時回饋與狀態同步**:
    *   **成功方**: 成功取得控制權的使用者，其前端會立即收到包含 `success: true`、`masterDeviceId` 及 `ttl` 的響應，UI 立刻更新為「主控模式」。
    *   **失敗方**: 幾乎同時點擊但失敗的使用者，會收到 `success: false` 及當前真正的主控者 `currentMasterId`。前端 UI 不會跳轉到主控模式，而是會彈出一個**友善的提示**：「哎呀！就在您點擊的瞬間，其他人搶先一步了！」，並將播放器切換至「鎖定模式」。
*   **定期心跳與自動過期**: 主控裝置會透過一個**定期心跳 (7秒一次)** 的 `updateMasterDeviceStatus` 請求來刷新其控制權的**生存時間 (TTL)**。如果主控者關閉頁面，心跳停止，TTL 過期後控制權將**自動釋放**，讓其他訪客可以接管。

這個「後端原子化 + 前端即時回饋」的閉環設計，確保了在極端並行請求下，系統狀態的**最終一致性 (Eventual Consistency)** 與絕佳的使用者體驗。

#### 2. 情境感知的 UI/UX 設計

我深信，好的 UI 不僅是美觀，更是**狀態的直觀反映**。為此，`MusicControlPanel` 元件被設計為一個**有限狀態機 (Finite State Machine)**，根據以下三種核心情境，動態渲染完全不同的介面：

| 狀態 (State) | 觸發條件 | UI/UX 呈現 | 設計理念 |
| :--- | :--- | :--- | :--- |
| **A: 主控模式** | `isMaster === true` | 顯示完整的播放控制項（播放/暫停、上下首、音量、隨機播放），並有「👑 您是目前的派對DJ」的尊榮標示。 | 給予使用者完全的**掌控感**與**成就感**。 |
| **B: 鎖定模式** | `isLocked === true` | 控制項變為**禁用 (Disabled)** 狀態，取而代之的是一個「🔒 由其他裝置控制中」的鎖定圖示，並顯示一個**動態倒數計時器**，明確告知使用者何時可以嘗試接管。 | 透過**明確的視覺回饋**消除使用者的困惑，並用倒數計時器給予**明確的預期**，將「等待」變成遊戲化的一環。 |
| **C: 搶佔模式** | `!isMaster && !isLocked` | 介面極簡化，只顯示一個醒目的「<Play/> 成為派對DJ」按鈕，鼓勵使用者點擊並加入互動。 | **降低參與門檻**，用最具吸引力的方式邀請使用者從「被動的聽眾」轉變為「主動的參與者」。 |

這種基於情境的設計，將複雜的後端狀態，轉化為使用者一看就懂、且充滿趣味的互動體驗。

#### 3. 安全與解耦的認證流程

**挑戰**：Spotify API 的 `access_token` 生命週期僅有 1 小時，且 `client_secret` 屬於高度敏感資訊，絕不能暴露在前端。如何設計一個既安全，又能無縫處理 `token` 刷新的認證流程，是此功能的關鍵。

**我的解決方案**：
*   **後端權責單一化 (Backend for Frontend, BFF)**: 我建立了一系列專職的 Next.js API Routes (`/api/spotify/*`) 作為**唯一的 Spotify 認證入口**。
    *   `client_id` 與 `client_secret` **僅存於後端環境變數**中，完全與前端隔離。
    *   後端負責處理完整的 OAuth 2.0 流程，包括獲取 `access_token` 與 `refresh_token`。
    *   `refresh_token` 等長期憑證被安全地儲存在**伺服器端的快取或資料庫**中，前端對此無感知。

*   **前端無感知刷新 (Transparent Token Refresh)**:
    *   前端向後端發起的**所有 Spotify 相關請求**（如 `play`, `pause`），都會先經過我自己後端的 API 路由。
    *   在後端 API 中，我實作了一個**攔截器 (Interceptor)**。它會檢查當前 `access_token` 是否即將過期。
    *   如果 `token` 過期，後端會**自動、同步地**使用 `refresh_token` 向 Spotify 換取一個全新的 `access_token`，然後才繼續執行使用者最初的請求（如 `play`）。
    *   整個刷新過程對前端**完全透明**，前端開發者無需關心任何 `token` 的生命週期管理，只需像呼叫普通 API 一樣進行操作即可。

這個架構不僅實現了**前後端的職責分離**，更透過**後端集中式的刷新策略**，確保了使用者在長達數小時的瀏覽過程中，音樂播放體驗也絕對不會因 `token` 過期而中斷。

### 🚀 現代化全端架構 (Modern Full-Stack Architecture)

採用業界前沿的技術棧，打造了一個高效、可擴充且易於維護的應用程式。

* **核心框架**: 以 **Next.js (App Router)** 為核心，充分利用 **React Server Components (RSC)** 的優勢，在伺服器端處理資料獲取與渲染，實現極致的載入效能與優良的開發體驗。
* **AI 服務高可用性架構**: 為了確保 AI 服務的極致穩定，我設計並實作了**主備援模型切換 (Primary-Fallback Model Switching)** 機制。
  * **主線模型 (`gemini-2.0-flash`)**: 日常選用兼具品質與穩定性的模型，提供最佳的 AI 人格演繹與對話體驗。
  * **備援模型 (`gemini-2.0-flash-lite`)**: 當主線模型因速率限制 (Rate Limit) 或暫時性錯誤而失敗時，後端會自動無縫切換至速度更快的備援模型，實作**優雅降級 (Graceful Degradation)**，確保服務不中斷。
* **全端能力**: 透過 **Next.js API Routes** 建立後端服務，安全地在伺服器端處理 **GitHub API** 的驗證與請求，實現了**動態專案儀表板**和**即時開發狀態追蹤**等功能。
* **智慧快取策略**: 針對不同的 API，分別採用 **60 秒** (開發任務) 和 **1 小時** (專案統計) 的**伺服器端增量靜態再生 (ISR) 快取**，在數據即時性、效能與成本之間取得了精準的平衡。
* **型別安全**: 全站使用 **TypeScript**，並藉由 **Contentlayer** 實現了從內容 (`.mdx`) 到元件 (`.tsx`) 的端到端型別安全，大幅提升了程式碼的健壯性與可維護性。

### 🧠 專業級搜尋引擎 (Professional-Grade Search Engine)

從零開始設計並實作了一套媲美專業文件網站的、完全在前端運行的即時搜尋系統。

* **關聯性優先排序**: 整合 **`FlexSearch.js`**，利用 **TF-IDF** 演算法取代傳統的關鍵字比對，讓搜尋結果真正按照「相關程度」排序。
* **智慧型多重索引**: 在建置時 (`Build-Time`) 將內容預處理為「**純文字**」、「**程式碼**」和「**數學公式**」三個獨立索引，並為**不同欄位設定不同權重** (`標題 > 標籤 > 內文 > 程式碼`)，實現了極高的搜尋精準度。
* **上下文感知查詢**: 搜尋邏輯能**自動偵測**使用者輸入的是「自然語言」還是「技術符號」，並**動態調整**搜尋策略，例如允許對程式碼中的單一字母變數進行搜尋。

### 🎨 應用程式級使用者體驗 (Application-Level User Experience)

專注於打造流暢、直觀、且充滿細節的互動體驗，讓網站從「頁面」提升至「產品」。

* **`⌘+K` 指揮中心**: 網站的核心互動中樞。實作了**巢狀（子母）指令介面**，不僅提供全站內容的毫秒級搜尋，更能執行「切換主題」、「複製資訊」等**動作**，並整合 API **即時顯示 GitHub 開發中任務**。
* **Spotify 深度整合**:
    * **主題曲插播**: 在不中斷現有播放佇列的情況下，無縫插播與文章或個人主題相關的歌曲。
    * **全功能控制**: `⌘+K` 指揮中心內建完整的音樂控制功能，包含播放、暫停、切歌、隨機播放、搜尋歌曲等，將音樂體驗與網站互動完美融合。
* **動態目錄 (TOC)**: 使用 **`IntersectionObserver` API** 實現捲動監聽，**自動高亮**使用者正在閱讀的章節，並以**手風琴效果**保持介面清爽，極大提升了長篇文章的導航效率。
* **細緻的 UI/UX**: 從 HackMD 風格的 UI 元素、`next/font` 優化的字體載入，到尊重系統偏好且可手動覆寫的**智慧型主題切換**，每一個細節都旨在提供最佳的閱讀與互動體驗。

### 🛠️ 最佳化內容管線 (Optimized Content Pipeline)

為技術內容的呈現，建立了一套高效且高品質的處理流程。

* **MDX 驅動**: 所有文章均採用 MDX 格式，允許在 Markdown 中無縫嵌入**互動式 React 元件**，為未來的 p5.js 視覺化等功能打下基礎。
* **高效語法高亮**: 透過 `rehype-pretty-code` + `shiki` 在**伺服器端**完成程式碼高亮，避免了客戶端的效能損耗，並提供媲美 VS Code 的視覺效果。
* **優雅的數學公式**: 整合 **KaTeX**，確保所有 LaTeX 數學公式都能被快速、正確且美觀地渲染。

---

## 🔗 全端 API 整合 (Full-Stack API Integration)

本專案不僅僅是一個靜態網站，更透過 Next.js 的後端 API 路由，實現了與 GitHub 服務的深度整合，展現了全端開發的能力。

### 1. 開發計畫儀表板 (Command Palette)

-   **API 路由**: `/api/github-issues/route.ts`
-   **核心功能**:
    -   安全地在伺服器端使用 `Octokit` 與 GitHub GraphQL API 溝通，讀取**私有 (Private) GitHub Project** 的開發狀態。
    -   將 Issues 篩選、分類為「待辦」與「進行中」，並整合於 `⌘+K` 的巢狀指令面板中。
-   **效能優化**: 採用 `revalidate = 60` (60 秒) 的快取策略，讓使用者在短時間內的重複操作能享受瞬時載入的體驗，同時確保開發狀態的高度即時性。

### 2. 專案統計儀表板 (Projects Page)

-   **API 路由**: `/api/github-stats/route.ts`
-   **核心功能**:
    -   批次抓取指定專案的星級 (Stars)、Fork 數、總提交數 (Total Commits) 等公開數據。
    -   API 部署於 Vercel 的 Edge Network (`runtime = 'edge'`)，提供全球性的低延遲回應。
-   **效能優化**: 考量到專案統計數據的變動頻率較低，採用 `revalidate = 3600` (1 小時) 的長效快取策略，在確保數據相對即時的同時，最大化效能並節省 API 請求資源。

---
## 🚀 如何在本機運行 (Setup and Run Locally)

1.  **複製專案 (Clone the repository):**
    ```bash
    git clone https://github.com/peienwu1216/peienwu-blog-next.git
    cd peienwu-blog-next
    ```

2.  **安裝依賴 (Install dependencies):**
    ```bash
    npm install
    # 或者 yarn install / pnpm install
    ```

3.  **啟動開發伺服器 (Start the development server):**
    ```bash
    npm run dev
    ```
    > `npm run dev` 指令會同時啟動 `contentlayer dev` 監視內容變更，並啟動 Next.js 開發伺服器。

    打開瀏覽器訪問 [http://localhost:3000](http://localhost:3000)。

4.  **環境變數設定 (Environment Variables):**
    此專案需要串接 GitHub API 來獲取開發計畫與專案統計資料。請在專案根目錄建立一個 `.env.local` 檔案，並填入以下內容：

    ```env
    # 用於讀取 GitHub repo 與 project 資訊的 Personal Access Token
    # 需要具備 `repo` 和 `read:project` 權限
    GITHUB_PAT="ghp_xxxxxxxxxxxxxxxxxxxx"

    # 您的 GitHub 使用者名稱
    GITHUB_USERNAME="your-github-username"

    # 您要追蹤的 GitHub Project 的數字編號
    GITHUB_PROJECT_ID="your-project-number"
    ```
    > **注意**: 當您將專案部署至 Vercel 等平台時，也必須在該平台的後台設定這些環境變數。

5.  **建置生產版本 (Build for production):**
    ```bash
    npm run build
    ```
